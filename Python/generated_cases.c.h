// This file is generated by Tools/cases_generator/generate_cases.py
// from:
//   Python/bytecodes.c
// Do not edit!

        TARGET(NOP) {
            DISPATCH();
        }

        TARGET(RESUME) {
            #line 136 "Python/bytecodes.c"
            assert(tstate->cframe == &cframe);
            assert(frame == cframe.current_frame);
            /* Possibly combine this with eval breaker */
            if (_PyFrame_GetCode(frame)->_co_instrumentation_version != tstate->interp->monitoring_version) {
                int err = _Py_Instrument(_PyFrame_GetCode(frame), tstate->interp);
                if (err) goto error;
                next_instr--;
            }
            else if (_Py_atomic_load_relaxed_int32(&tstate->interp->ceval.eval_breaker) && oparg < 2) {
                goto handle_eval_breaker;
            }
            #line 24 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_RESUME) {
            #line 150 "Python/bytecodes.c"
            /* Possible performance enhancement:
             *   We need to check the eval breaker anyway, can we
             * combine the instrument verison check and the eval breaker test?
             */
            if (_PyFrame_GetCode(frame)->_co_instrumentation_version != tstate->interp->monitoring_version) {
                if (_Py_Instrument(_PyFrame_GetCode(frame), tstate->interp)) {
                    goto error;
                }
                next_instr--;
            }
            else {
                _PyFrame_SetStackPointer(frame, stack_pointer);
                int err = _Py_call_instrumentation(
                        tstate, oparg > 0, frame, next_instr-1);
                stack_pointer = _PyFrame_GetStackPointer(frame);
                if (err) goto error;
                if (frame->prev_instr != next_instr-1) {
                    /* Instrumentation has jumped */
                    next_instr = frame->prev_instr;
                    DISPATCH();
                }
                if (_Py_atomic_load_relaxed_int32(&tstate->interp->ceval.eval_breaker) && oparg < 2) {
                    goto handle_eval_breaker;
                }
            }
            #line 55 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(LOAD_FAST_CHECK) {
            PyObject *value;
            #line 182 "Python/bytecodes.c"
            value = GETLOCAL(oparg);
            if (value == NULL) goto unbound_local_error;
            Py_INCREF(value);
            #line 65 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(LOAD_FAST) {
            PyObject *value;
            #line 188 "Python/bytecodes.c"
            value = GETLOCAL(oparg);
            assert(value != NULL);
            Py_INCREF(value);
            #line 77 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(LOAD_FAST_AND_CLEAR) {
            PyObject *value;
            #line 194 "Python/bytecodes.c"
            value = GETLOCAL(oparg);
            // do not use SETLOCAL here, it decrefs the old value
            GETLOCAL(oparg) = NULL;
            #line 89 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(LOAD_FAST_LOAD_FAST) {
            PyObject *value1;
            PyObject *value2;
            #line 200 "Python/bytecodes.c"
            uint32_t oparg1 = oparg >> 4;
            uint32_t oparg2 = oparg & 15;
            value1 = GETLOCAL(oparg1);
            value2 = GETLOCAL(oparg2);
            Py_INCREF(value1);
            Py_INCREF(value2);
            #line 105 "Python/generated_cases.c.h"
            STACK_GROW(2);
            stack_pointer[-1] = value2;
            stack_pointer[-2] = value1;
            DISPATCH();
        }

        TARGET(LOAD_CONST) {
            PyObject *value;
            #line 209 "Python/bytecodes.c"
            value = GETITEM(FRAME_CO_CONSTS, oparg);
            Py_INCREF(value);
            #line 117 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(STORE_FAST) {
            PyObject *value = stack_pointer[-1];
            #line 214 "Python/bytecodes.c"
            SETLOCAL(oparg, value);
            #line 127 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(STORE_FAST_LOAD_FAST) {
            PyObject *value1 = stack_pointer[-1];
            PyObject *value2;
            #line 222 "Python/bytecodes.c"
            uint32_t oparg1 = oparg >> 4;
            uint32_t oparg2 = oparg & 15;
            SETLOCAL(oparg1, value1);
            value2 = GETLOCAL(oparg2);
            Py_INCREF(value2);
            #line 141 "Python/generated_cases.c.h"
            stack_pointer[-1] = value2;
            DISPATCH();
        }

        TARGET(STORE_FAST_STORE_FAST) {
            PyObject *value1 = stack_pointer[-1];
            PyObject *value2 = stack_pointer[-2];
            #line 230 "Python/bytecodes.c"
            uint32_t oparg1 = oparg >> 4;
            uint32_t oparg2 = oparg & 15;
            SETLOCAL(oparg1, value1);
            SETLOCAL(oparg2, value2);
            #line 154 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(POP_TOP) {
            PyObject *value = stack_pointer[-1];
            #line 237 "Python/bytecodes.c"
            #line 162 "Python/generated_cases.c.h"
            Py_DECREF(value);
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(PUSH_NULL) {
            PyObject *res;
            #line 241 "Python/bytecodes.c"
            res = NULL;
            #line 172 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(END_FOR) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *value = _tmp_1;
                #line 237 "Python/bytecodes.c"
                #line 184 "Python/generated_cases.c.h"
                Py_DECREF(value);
            }
            {
                PyObject *value = _tmp_2;
                #line 237 "Python/bytecodes.c"
                #line 190 "Python/generated_cases.c.h"
                Py_DECREF(value);
            }
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(INSTRUMENTED_END_FOR) {
            PyObject *value = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            #line 247 "Python/bytecodes.c"
            /* Need to create a fake StopIteration error here,
             * to conform to PEP 380 */
            if (PyGen_Check(receiver)) {
                PyErr_SetObject(PyExc_StopIteration, value);
                if (monitor_stop_iteration(tstate, frame, next_instr-1)) {
                    goto error;
                }
                PyErr_SetRaisedException(NULL);
            }
            #line 210 "Python/generated_cases.c.h"
            Py_DECREF(receiver);
            Py_DECREF(value);
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(END_SEND) {
            PyObject *value = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            #line 260 "Python/bytecodes.c"
            Py_DECREF(receiver);
            #line 222 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(INSTRUMENTED_END_SEND) {
            PyObject *value = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            #line 264 "Python/bytecodes.c"
            if (PyGen_Check(receiver) || PyCoro_CheckExact(receiver)) {
                PyErr_SetObject(PyExc_StopIteration, value);
                if (monitor_stop_iteration(tstate, frame, next_instr-1)) {
                    goto error;
                }
                PyErr_SetRaisedException(NULL);
            }
            Py_DECREF(receiver);
            #line 240 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(UNARY_NEGATIVE) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 275 "Python/bytecodes.c"
            res = PyNumber_Negative(value);
            #line 251 "Python/generated_cases.c.h"
            Py_DECREF(value);
            #line 277 "Python/bytecodes.c"
            if (res == NULL) goto pop_1_error;
            #line 255 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(UNARY_NOT) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 281 "Python/bytecodes.c"
            assert(PyBool_Check(value));
            res = Py_IsFalse(value) ? Py_True : Py_False;
            #line 266 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(TO_BOOL) {
            PREDICTED(TO_BOOL);
            static_assert(INLINE_CACHE_ENTRIES_TO_BOOL == 3, "incorrect cache size");
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 296 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyToBoolCache *cache = (_PyToBoolCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_ToBool(value, next_instr);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(TO_BOOL, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            int err = PyObject_IsTrue(value);
            #line 288 "Python/generated_cases.c.h"
            Py_DECREF(value);
            #line 308 "Python/bytecodes.c"
            if (err < 0) goto pop_1_error;
            res = err ? Py_True : Py_False;
            #line 293 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_BOOL) {
            PyObject *value = stack_pointer[-1];
            #line 313 "Python/bytecodes.c"
            DEOPT_IF(!PyBool_Check(value), TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            #line 304 "Python/generated_cases.c.h"
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_INT) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 318 "Python/bytecodes.c"
            DEOPT_IF(!PyLong_CheckExact(value), TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            if (_PyLong_IsZero((PyLongObject *)value)) {
                assert(_Py_IsImmortal(value));
                res = Py_False;
            }
            else {
            #line 320 "Python/generated_cases.c.h"
                Py_DECREF(value);
            #line 326 "Python/bytecodes.c"
                res = Py_True;
            }
            #line 325 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_LIST) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 331 "Python/bytecodes.c"
            DEOPT_IF(!PyList_CheckExact(value), TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            res = Py_SIZE(value) ? Py_True : Py_False;
            #line 338 "Python/generated_cases.c.h"
            Py_DECREF(value);
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_NONE) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 338 "Python/bytecodes.c"
            // This one is a bit weird, because we expect *some* failures:
            DEOPT_IF(!Py_IsNone(value), TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            res = Py_False;
            #line 353 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_STR) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 345 "Python/bytecodes.c"
            DEOPT_IF(!PyUnicode_CheckExact(value), TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            if (value == &_Py_STR(empty)) {
                assert(_Py_IsImmortal(value));
                res = Py_False;
            }
            else {
                assert(Py_SIZE(value));
            #line 371 "Python/generated_cases.c.h"
                Py_DECREF(value);
            #line 354 "Python/bytecodes.c"
                res = Py_True;
            }
            #line 376 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(TO_BOOL_ALWAYS_TRUE) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            uint32_t version = read_u32(&next_instr[1].cache);
            #line 359 "Python/bytecodes.c"
            // This one is a bit weird, because we expect *some* failures:
            assert(version);
            DEOPT_IF(Py_TYPE(value)->tp_version_tag != version, TO_BOOL);
            STAT_INC(TO_BOOL, hit);
            #line 391 "Python/generated_cases.c.h"
            Py_DECREF(value);
            #line 364 "Python/bytecodes.c"
            res = Py_True;
            #line 395 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(UNARY_INVERT) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 368 "Python/bytecodes.c"
            res = PyNumber_Invert(value);
            #line 406 "Python/generated_cases.c.h"
            Py_DECREF(value);
            #line 370 "Python/bytecodes.c"
            if (res == NULL) goto pop_1_error;
            #line 410 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(BINARY_OP_MULTIPLY_INT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 386 "Python/bytecodes.c"
                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);
                #line 424 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 391 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error;
                #line 438 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_ADD_INT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 386 "Python/bytecodes.c"
                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);
                #line 456 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 399 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error;
                #line 470 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_SUBTRACT_INT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 386 "Python/bytecodes.c"
                DEOPT_IF(!PyLong_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyLong_CheckExact(right), BINARY_OP);
                #line 488 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 407 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error;
                #line 502 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_MULTIPLY_FLOAT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 422 "Python/bytecodes.c"
                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);
                #line 520 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 427 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval *
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                #line 534 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_ADD_FLOAT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 422 "Python/bytecodes.c"
                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);
                #line 552 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 435 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval +
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                #line 566 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_SUBTRACT_FLOAT) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 422 "Python/bytecodes.c"
                DEOPT_IF(!PyFloat_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyFloat_CheckExact(right), BINARY_OP);
                #line 584 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 443 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval -
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                #line 598 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_ADD_UNICODE) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 458 "Python/bytecodes.c"
                DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyUnicode_CheckExact(right), BINARY_OP);
                #line 616 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                PyObject *res;
                #line 463 "Python/bytecodes.c"
                STAT_INC(BINARY_OP, hit);
                res = PyUnicode_Concat(left, right);
                _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);
                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
                if (res == NULL) goto pop_2_error;
                #line 630 "Python/generated_cases.c.h"
                _tmp_2 = res;
            }
            next_instr += 1;
            STACK_SHRINK(1);
            stack_pointer[-1] = _tmp_2;
            DISPATCH();
        }

        TARGET(BINARY_OP_INPLACE_ADD_UNICODE) {
            PyObject *_tmp_1 = stack_pointer[-1];
            PyObject *_tmp_2 = stack_pointer[-2];
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 458 "Python/bytecodes.c"
                DEOPT_IF(!PyUnicode_CheckExact(left), BINARY_OP);
                DEOPT_IF(!PyUnicode_CheckExact(right), BINARY_OP);
                #line 648 "Python/generated_cases.c.h"
                _tmp_2 = left;
                _tmp_1 = right;
            }
            {
                PyObject *right = _tmp_1;
                PyObject *left = _tmp_2;
                #line 480 "Python/bytecodes.c"
                _Py_CODEUNIT true_next = next_instr[INLINE_CACHE_ENTRIES_BINARY_OP];
                assert(true_next.op.code == STORE_FAST);
                PyObject **target_local = &GETLOCAL(true_next.op.arg);
                DEOPT_IF(*target_local != left, BINARY_OP);
                STAT_INC(BINARY_OP, hit);
                /* Handle `left = left + right` or `left += right` for str.
                 *
                 * When possible, extend `left` in place rather than
                 * allocating a new PyUnicodeObject. This attempts to avoid
                 * quadratic behavior when one neglects to use str.join().
                 *
                 * If `left` has only two references remaining (one from
                 * the stack, one in the locals), DECREFing `left` leaves
                 * only the locals reference, so PyUnicode_Append knows
                 * that the string is safe to mutate.
                 */
                assert(Py_REFCNT(left) >= 2);
                _Py_DECREF_NO_DEALLOC(left);
                PyUnicode_Append(target_local, right);
                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
                if (*target_local == NULL) goto pop_2_error;
                // The STORE_FAST is already done.
                SKIP_OVER(INLINE_CACHE_ENTRIES_BINARY_OP + 1);
                #line 679 "Python/generated_cases.c.h"
            }
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(BINARY_SUBSCR) {
            PREDICTED(BINARY_SUBSCR);
            static_assert(INLINE_CACHE_ENTRIES_BINARY_SUBSCR == 1, "incorrect cache size");
            PyObject *sub = stack_pointer[-1];
            PyObject *container = stack_pointer[-2];
            PyObject *res;
            #line 517 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyBinarySubscrCache *cache = (_PyBinarySubscrCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_BinarySubscr(container, sub, next_instr);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(BINARY_SUBSCR, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            res = PyObject_GetItem(container, sub);
            #line 703 "Python/generated_cases.c.h"
            Py_DECREF(container);
            Py_DECREF(sub);
            #line 529 "Python/bytecodes.c"
            if (res == NULL) goto pop_2_error;
            #line 708 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(BINARY_SLICE) {
            PyObject *stop = stack_pointer[-1];
            PyObject *start = stack_pointer[-2];
            PyObject *container = stack_pointer[-3];
            PyObject *res;
            #line 533 "Python/bytecodes.c"
            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);
            // Can't use ERROR_IF() here, because we haven't
            // DECREF'ed container yet, and we still own slice.
            if (slice == NULL) {
                res = NULL;
            }
            else {
                res = PyObject_GetItem(container, slice);
                Py_DECREF(slice);
            }
            Py_DECREF(container);
            if (res == NULL) goto pop_3_error;
            #line 733 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(STORE_SLICE) {
            PyObject *stop = stack_pointer[-1];
            PyObject *start = stack_pointer[-2];
            PyObject *container = stack_pointer[-3];
            PyObject *v = stack_pointer[-4];
            #line 548 "Python/bytecodes.c"
            PyObject *slice = _PyBuildSlice_ConsumeRefs(start, stop);
            int err;
            if (slice == NULL) {
                err = 1;
            }
            else {
                err = PyObject_SetItem(container, slice, v);
                Py_DECREF(slice);
            }
            Py_DECREF(v);
            Py_DECREF(container);
            if (err) goto pop_4_error;
            #line 757 "Python/generated_cases.c.h"
            STACK_SHRINK(4);
            DISPATCH();
        }

        TARGET(BINARY_SUBSCR_LIST_INT) {
            PyObject *sub = stack_pointer[-1];
            PyObject *list = stack_pointer[-2];
            PyObject *res;
            #line 563 "Python/bytecodes.c"
            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);
            DEOPT_IF(!PyList_CheckExact(list), BINARY_SUBSCR);

            // Deopt unless 0 <= sub < PyList_Size(list)
            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            DEOPT_IF(index >= PyList_GET_SIZE(list), BINARY_SUBSCR);
            STAT_INC(BINARY_SUBSCR, hit);
            res = PyList_GET_ITEM(list, index);
            assert(res != NULL);
            Py_INCREF(res);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF(list);
            #line 780 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(BINARY_SUBSCR_TUPLE_INT) {
            PyObject *sub = stack_pointer[-1];
            PyObject *tuple = stack_pointer[-2];
            PyObject *res;
            #line 579 "Python/bytecodes.c"
            DEOPT_IF(!PyLong_CheckExact(sub), BINARY_SUBSCR);
            DEOPT_IF(!PyTuple_CheckExact(tuple), BINARY_SUBSCR);

            // Deopt unless 0 <= sub < PyTuple_Size(list)
            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), BINARY_SUBSCR);
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            DEOPT_IF(index >= PyTuple_GET_SIZE(tuple), BINARY_SUBSCR);
            STAT_INC(BINARY_SUBSCR, hit);
            res = PyTuple_GET_ITEM(tuple, index);
            assert(res != NULL);
            Py_INCREF(res);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF(tuple);
            #line 805 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(BINARY_SUBSCR_DICT) {
            PyObject *sub = stack_pointer[-1];
            PyObject *dict = stack_pointer[-2];
            PyObject *res;
            #line 595 "Python/bytecodes.c"
            DEOPT_IF(!PyDict_CheckExact(dict), BINARY_SUBSCR);
            STAT_INC(BINARY_SUBSCR, hit);
            res = PyDict_GetItemWithError(dict, sub);
            if (res == NULL) {
                if (!_PyErr_Occurred(tstate)) {
                    _PyErr_SetKeyError(sub);
                }
            #line 824 "Python/generated_cases.c.h"
                Py_DECREF(dict);
                Py_DECREF(sub);
            #line 603 "Python/bytecodes.c"
                if (true) goto pop_2_error;
            }
            Py_INCREF(res);  // Do this before DECREF'ing dict, sub
            #line 831 "Python/generated_cases.c.h"
            Py_DECREF(dict);
            Py_DECREF(sub);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(BINARY_SUBSCR_GETITEM) {
            PyObject *sub = stack_pointer[-1];
            PyObject *container = stack_pointer[-2];
            #line 610 "Python/bytecodes.c"
            DEOPT_IF(tstate->interp->eval_frame, BINARY_SUBSCR);
            PyTypeObject *tp = Py_TYPE(container);
            DEOPT_IF(!PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE), BINARY_SUBSCR);
            PyHeapTypeObject *ht = (PyHeapTypeObject *)tp;
            PyObject *cached = ht->_spec_cache.getitem;
            DEOPT_IF(cached == NULL, BINARY_SUBSCR);
            assert(PyFunction_Check(cached));
            PyFunctionObject *getitem = (PyFunctionObject *)cached;
            uint32_t cached_version = ht->_spec_cache.getitem_version;
            DEOPT_IF(getitem->func_version != cached_version, BINARY_SUBSCR);
            PyCodeObject *code = (PyCodeObject *)getitem->func_code;
            assert(code->co_argcount == 2);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), BINARY_SUBSCR);
            STAT_INC(BINARY_SUBSCR, hit);
            Py_INCREF(getitem);
            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, getitem, 2);
            STACK_SHRINK(2);
            new_frame->localsplus[0] = container;
            new_frame->localsplus[1] = sub;
            SKIP_OVER(INLINE_CACHE_ENTRIES_BINARY_SUBSCR);
            frame->return_offset = 0;
            DISPATCH_INLINED(new_frame);
            #line 866 "Python/generated_cases.c.h"
        }

        TARGET(LIST_APPEND) {
            PyObject *v = stack_pointer[-1];
            PyObject *list = stack_pointer[-(2 + (oparg-1))];
            #line 635 "Python/bytecodes.c"
            if (_PyList_AppendTakeRef((PyListObject *)list, v) < 0) goto pop_1_error;
            #line 874 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(SET_ADD) {
            PyObject *v = stack_pointer[-1];
            PyObject *set = stack_pointer[-(2 + (oparg-1))];
            #line 639 "Python/bytecodes.c"
            int err = PySet_Add(set, v);
            #line 884 "Python/generated_cases.c.h"
            Py_DECREF(v);
            #line 641 "Python/bytecodes.c"
            if (err) goto pop_1_error;
            #line 888 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(STORE_SUBSCR) {
            PREDICTED(STORE_SUBSCR);
            static_assert(INLINE_CACHE_ENTRIES_STORE_SUBSCR == 1, "incorrect cache size");
            PyObject *sub = stack_pointer[-1];
            PyObject *container = stack_pointer[-2];
            PyObject *v = stack_pointer[-3];
            uint16_t counter = read_u16(&next_instr[0].cache);
            #line 651 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            if (ADAPTIVE_COUNTER_IS_ZERO(counter)) {
                next_instr--;
                _Py_Specialize_StoreSubscr(container, sub, next_instr);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(STORE_SUBSCR, deferred);
            _PyStoreSubscrCache *cache = (_PyStoreSubscrCache *)next_instr;
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #else
            (void)counter;  // Unused.
            #endif  /* ENABLE_SPECIALIZATION */
            /* container[sub] = v */
            int err = PyObject_SetItem(container, sub, v);
            #line 915 "Python/generated_cases.c.h"
            Py_DECREF(v);
            Py_DECREF(container);
            Py_DECREF(sub);
            #line 666 "Python/bytecodes.c"
            if (err) goto pop_3_error;
            #line 921 "Python/generated_cases.c.h"
            STACK_SHRINK(3);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(STORE_SUBSCR_LIST_INT) {
            PyObject *sub = stack_pointer[-1];
            PyObject *list = stack_pointer[-2];
            PyObject *value = stack_pointer[-3];
            #line 670 "Python/bytecodes.c"
            DEOPT_IF(!PyLong_CheckExact(sub), STORE_SUBSCR);
            DEOPT_IF(!PyList_CheckExact(list), STORE_SUBSCR);

            // Ensure nonnegative, zero-or-one-digit ints.
            DEOPT_IF(!_PyLong_IsNonNegativeCompact((PyLongObject *)sub), STORE_SUBSCR);
            Py_ssize_t index = ((PyLongObject*)sub)->long_value.ob_digit[0];
            // Ensure index < len(list)
            DEOPT_IF(index >= PyList_GET_SIZE(list), STORE_SUBSCR);
            STAT_INC(STORE_SUBSCR, hit);

            PyObject *old_value = PyList_GET_ITEM(list, index);
            PyList_SET_ITEM(list, index, value);
            assert(old_value != NULL);
            Py_DECREF(old_value);
            _Py_DECREF_SPECIALIZED(sub, (destructor)PyObject_Free);
            Py_DECREF(list);
            #line 948 "Python/generated_cases.c.h"
            STACK_SHRINK(3);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(STORE_SUBSCR_DICT) {
            PyObject *sub = stack_pointer[-1];
            PyObject *dict = stack_pointer[-2];
            PyObject *value = stack_pointer[-3];
            #line 689 "Python/bytecodes.c"
            DEOPT_IF(!PyDict_CheckExact(dict), STORE_SUBSCR);
            STAT_INC(STORE_SUBSCR, hit);
            int err = _PyDict_SetItem_Take2((PyDictObject *)dict, sub, value);
            Py_DECREF(dict);
            if (err) goto pop_3_error;
            #line 964 "Python/generated_cases.c.h"
            STACK_SHRINK(3);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(DELETE_SUBSCR) {
            PyObject *sub = stack_pointer[-1];
            PyObject *container = stack_pointer[-2];
            #line 697 "Python/bytecodes.c"
            /* del container[sub] */
            int err = PyObject_DelItem(container, sub);
            #line 976 "Python/generated_cases.c.h"
            Py_DECREF(container);
            Py_DECREF(sub);
            #line 700 "Python/bytecodes.c"
            if (err) goto pop_2_error;
            #line 981 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(CALL_INTRINSIC_1) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 704 "Python/bytecodes.c"
            assert(oparg <= MAX_INTRINSIC_1);
            res = _PyIntrinsics_UnaryFunctions[oparg](tstate, value);
            #line 992 "Python/generated_cases.c.h"
            Py_DECREF(value);
            #line 707 "Python/bytecodes.c"
            if (res == NULL) goto pop_1_error;
            #line 996 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(CALL_INTRINSIC_2) {
            PyObject *value1 = stack_pointer[-1];
            PyObject *value2 = stack_pointer[-2];
            PyObject *res;
            #line 711 "Python/bytecodes.c"
            assert(oparg <= MAX_INTRINSIC_2);
            res = _PyIntrinsics_BinaryFunctions[oparg](tstate, value2, value1);
            #line 1008 "Python/generated_cases.c.h"
            Py_DECREF(value2);
            Py_DECREF(value1);
            #line 714 "Python/bytecodes.c"
            if (res == NULL) goto pop_2_error;
            #line 1013 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(RAISE_VARARGS) {
            PyObject **args = (stack_pointer - oparg);
            #line 718 "Python/bytecodes.c"
            PyObject *cause = NULL, *exc = NULL;
            switch (oparg) {
            case 2:
                cause = args[1];
                /* fall through */
            case 1:
                exc = args[0];
                /* fall through */
            case 0:
                if (do_raise(tstate, exc, cause)) { STACK_SHRINK(oparg); goto exception_unwind; }
                break;
            default:
                _PyErr_SetString(tstate, PyExc_SystemError,
                                 "bad RAISE_VARARGS oparg");
                break;
            }
            if (true) { STACK_SHRINK(oparg); goto error; }
            #line 1039 "Python/generated_cases.c.h"
        }

        TARGET(INTERPRETER_EXIT) {
            PyObject *retval = stack_pointer[-1];
            #line 738 "Python/bytecodes.c"
            assert(frame == &entry_frame);
            assert(_PyFrame_IsIncomplete(frame));
            /* Restore previous cframe and return. */
            tstate->cframe = cframe.previous;
            assert(tstate->cframe->current_frame == frame->previous);
            assert(!_PyErr_Occurred(tstate));
            _Py_LeaveRecursiveCallTstate(tstate);
            return retval;
            #line 1053 "Python/generated_cases.c.h"
        }

        TARGET(RETURN_VALUE) {
            PyObject *retval = stack_pointer[-1];
            #line 749 "Python/bytecodes.c"
            STACK_SHRINK(1);
            assert(EMPTY());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _Py_LeaveRecursiveCallPy(tstate);
            assert(frame != &entry_frame);
            // GH-99729: We need to unlink the frame *before* clearing it:
            _PyInterpreterFrame *dying = frame;
            frame = cframe.current_frame = dying->previous;
            _PyEvalFrameClearAndPop(tstate, dying);
            frame->prev_instr += frame->return_offset;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1071 "Python/generated_cases.c.h"
        }

        TARGET(INSTRUMENTED_RETURN_VALUE) {
            PyObject *retval = stack_pointer[-1];
            #line 764 "Python/bytecodes.c"
            int err = _Py_call_instrumentation_arg(
                    tstate, PY_MONITORING_EVENT_PY_RETURN,
                    frame, next_instr-1, retval);
            if (err) goto error;
            STACK_SHRINK(1);
            assert(EMPTY());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _Py_LeaveRecursiveCallPy(tstate);
            assert(frame != &entry_frame);
            // GH-99729: We need to unlink the frame *before* clearing it:
            _PyInterpreterFrame *dying = frame;
            frame = cframe.current_frame = dying->previous;
            _PyEvalFrameClearAndPop(tstate, dying);
            frame->prev_instr += frame->return_offset;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1093 "Python/generated_cases.c.h"
        }

        TARGET(RETURN_CONST) {
            #line 783 "Python/bytecodes.c"
            PyObject *retval = GETITEM(FRAME_CO_CONSTS, oparg);
            Py_INCREF(retval);
            assert(EMPTY());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _Py_LeaveRecursiveCallPy(tstate);
            assert(frame != &entry_frame);
            // GH-99729: We need to unlink the frame *before* clearing it:
            _PyInterpreterFrame *dying = frame;
            frame = cframe.current_frame = dying->previous;
            _PyEvalFrameClearAndPop(tstate, dying);
            frame->prev_instr += frame->return_offset;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1111 "Python/generated_cases.c.h"
        }

        TARGET(INSTRUMENTED_RETURN_CONST) {
            #line 799 "Python/bytecodes.c"
            PyObject *retval = GETITEM(FRAME_CO_CONSTS, oparg);
            int err = _Py_call_instrumentation_arg(
                    tstate, PY_MONITORING_EVENT_PY_RETURN,
                    frame, next_instr-1, retval);
            if (err) goto error;
            Py_INCREF(retval);
            assert(EMPTY());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _Py_LeaveRecursiveCallPy(tstate);
            assert(frame != &entry_frame);
            // GH-99729: We need to unlink the frame *before* clearing it:
            _PyInterpreterFrame *dying = frame;
            frame = cframe.current_frame = dying->previous;
            _PyEvalFrameClearAndPop(tstate, dying);
            frame->prev_instr += frame->return_offset;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1133 "Python/generated_cases.c.h"
        }

        TARGET(GET_AITER) {
            PyObject *obj = stack_pointer[-1];
            PyObject *iter;
            #line 819 "Python/bytecodes.c"
            unaryfunc getter = NULL;
            PyTypeObject *type = Py_TYPE(obj);

            if (type->tp_as_async != NULL) {
                getter = type->tp_as_async->am_aiter;
            }

            if (getter == NULL) {
                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' requires an object with "
                              "__aiter__ method, got %.100s",
                              type->tp_name);
            #line 1152 "Python/generated_cases.c.h"
                Py_DECREF(obj);
            #line 832 "Python/bytecodes.c"
                if (true) goto pop_1_error;
            }

            iter = (*getter)(obj);
            #line 1159 "Python/generated_cases.c.h"
            Py_DECREF(obj);
            #line 837 "Python/bytecodes.c"
            if (iter == NULL) goto pop_1_error;

            if (Py_TYPE(iter)->tp_as_async == NULL ||
                    Py_TYPE(iter)->tp_as_async->am_anext == NULL) {

                _PyErr_Format(tstate, PyExc_TypeError,
                              "'async for' received an object from __aiter__ "
                              "that does not implement __anext__: %.100s",
                              Py_TYPE(iter)->tp_name);
                Py_DECREF(iter);
                if (true) goto pop_1_error;
            }
            #line 1174 "Python/generated_cases.c.h"
            stack_pointer[-1] = iter;
            DISPATCH();
        }

        TARGET(GET_ANEXT) {
            PyObject *aiter = stack_pointer[-1];
            PyObject *awaitable;
            #line 852 "Python/bytecodes.c"
            unaryfunc getter = NULL;
            PyObject *next_iter = NULL;
            PyTypeObject *type = Py_TYPE(aiter);

            if (PyAsyncGen_CheckExact(aiter)) {
                awaitable = type->tp_as_async->am_anext(aiter);
                if (awaitable == NULL) {
                    goto error;
                }
            } else {
                if (type->tp_as_async != NULL){
                    getter = type->tp_as_async->am_anext;
                }

                if (getter != NULL) {
                    next_iter = (*getter)(aiter);
                    if (next_iter == NULL) {
                        goto error;
                    }
                }
                else {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'async for' requires an iterator with "
                                  "__anext__ method, got %.100s",
                                  type->tp_name);
                    goto error;
                }

                awaitable = _PyCoro_GetAwaitableIter(next_iter);
                if (awaitable == NULL) {
                    _PyErr_FormatFromCause(
                        PyExc_TypeError,
                        "'async for' received an invalid object "
                        "from __anext__: %.100s",
                        Py_TYPE(next_iter)->tp_name);

                    Py_DECREF(next_iter);
                    goto error;
                } else {
                    Py_DECREF(next_iter);
                }
            }
            #line 1225 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = awaitable;
            DISPATCH();
        }

        TARGET(GET_AWAITABLE) {
            PyObject *iterable = stack_pointer[-1];
            PyObject *iter;
            #line 897 "Python/bytecodes.c"
            iter = _PyCoro_GetAwaitableIter(iterable);

            if (iter == NULL) {
                format_awaitable_error(tstate, Py_TYPE(iterable), oparg);
            }

            #line 1241 "Python/generated_cases.c.h"
            Py_DECREF(iterable);
            #line 904 "Python/bytecodes.c"

            if (iter != NULL && PyCoro_CheckExact(iter)) {
                PyObject *yf = _PyGen_yf((PyGenObject*)iter);
                if (yf != NULL) {
                    /* `iter` is a coroutine object that is being
                       awaited, `yf` is a pointer to the current awaitable
                       being awaited on. */
                    Py_DECREF(yf);
                    Py_CLEAR(iter);
                    _PyErr_SetString(tstate, PyExc_RuntimeError,
                                     "coroutine is being awaited already");
                    /* The code below jumps to `error` if `iter` is NULL. */
                }
            }

            if (iter == NULL) goto pop_1_error;
            #line 1260 "Python/generated_cases.c.h"
            stack_pointer[-1] = iter;
            DISPATCH();
        }

        TARGET(SEND) {
            PREDICTED(SEND);
            static_assert(INLINE_CACHE_ENTRIES_SEND == 1, "incorrect cache size");
            PyObject *v = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            PyObject *retval;
            #line 928 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PySendCache *cache = (_PySendCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_Send(receiver, next_instr);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(SEND, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            assert(frame != &entry_frame);
            if ((tstate->interp->eval_frame == NULL) &&
                (Py_TYPE(receiver) == &PyGen_Type || Py_TYPE(receiver) == &PyCoro_Type) &&
                ((PyGenObject *)receiver)->gi_frame_state < FRAME_EXECUTING)
            {
                PyGenObject *gen = (PyGenObject *)receiver;
                _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;
                frame->return_offset = oparg;
                STACK_SHRINK(1);
                _PyFrame_StackPush(gen_frame, v);
                gen->gi_frame_state = FRAME_EXECUTING;
                gen->gi_exc_state.previous_item = tstate->exc_info;
                tstate->exc_info = &gen->gi_exc_state;
                SKIP_OVER(INLINE_CACHE_ENTRIES_SEND);
                DISPATCH_INLINED(gen_frame);
            }
            if (Py_IsNone(v) && PyIter_Check(receiver)) {
                retval = Py_TYPE(receiver)->tp_iternext(receiver);
            }
            else {
                retval = PyObject_CallMethodOneArg(receiver, &_Py_ID(send), v);
            }
            if (retval == NULL) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)
                ) {
                    monitor_raise(tstate, frame, next_instr-1);
                }
                if (_PyGen_FetchStopIterationValue(&retval) == 0) {
                    assert(retval != NULL);
                    JUMPBY(oparg);
                }
                else {
                    goto error;
                }
            }
            Py_DECREF(v);
            #line 1318 "Python/generated_cases.c.h"
            stack_pointer[-1] = retval;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(SEND_GEN) {
            PyObject *v = stack_pointer[-1];
            PyObject *receiver = stack_pointer[-2];
            #line 977 "Python/bytecodes.c"
            DEOPT_IF(tstate->interp->eval_frame, SEND);
            PyGenObject *gen = (PyGenObject *)receiver;
            DEOPT_IF(Py_TYPE(gen) != &PyGen_Type &&
                     Py_TYPE(gen) != &PyCoro_Type, SEND);
            DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, SEND);
            STAT_INC(SEND, hit);
            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;
            frame->return_offset = oparg;
            STACK_SHRINK(1);
            _PyFrame_StackPush(gen_frame, v);
            gen->gi_frame_state = FRAME_EXECUTING;
            gen->gi_exc_state.previous_item = tstate->exc_info;
            tstate->exc_info = &gen->gi_exc_state;
            SKIP_OVER(INLINE_CACHE_ENTRIES_SEND);
            DISPATCH_INLINED(gen_frame);
            #line 1343 "Python/generated_cases.c.h"
        }

        TARGET(INSTRUMENTED_YIELD_VALUE) {
            PyObject *retval = stack_pointer[-1];
            #line 995 "Python/bytecodes.c"
            assert(frame != &entry_frame);
            assert(oparg >= 0); /* make the generator identify this as HAS_ARG */
            PyGenObject *gen = _PyFrame_GetGenerator(frame);
            gen->gi_frame_state = FRAME_SUSPENDED;
            _PyFrame_SetStackPointer(frame, stack_pointer - 1);
            int err = _Py_call_instrumentation_arg(
                    tstate, PY_MONITORING_EVENT_PY_YIELD,
                    frame, next_instr-1, retval);
            if (err) goto error;
            tstate->exc_info = gen->gi_exc_state.previous_item;
            gen->gi_exc_state.previous_item = NULL;
            _Py_LeaveRecursiveCallPy(tstate);
            _PyInterpreterFrame *gen_frame = frame;
            frame = cframe.current_frame = frame->previous;
            gen_frame->previous = NULL;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1366 "Python/generated_cases.c.h"
        }

        TARGET(YIELD_VALUE) {
            PyObject *retval = stack_pointer[-1];
            #line 1015 "Python/bytecodes.c"
            // NOTE: It's important that YIELD_VALUE never raises an exception!
            // The compiler treats any exception raised here as a failed close()
            // or throw() call.
            assert(oparg >= 0); /* make the generator identify this as HAS_ARG */
            assert(frame != &entry_frame);
            PyGenObject *gen = _PyFrame_GetGenerator(frame);
            gen->gi_frame_state = FRAME_SUSPENDED;
            _PyFrame_SetStackPointer(frame, stack_pointer - 1);
            tstate->exc_info = gen->gi_exc_state.previous_item;
            gen->gi_exc_state.previous_item = NULL;
            _Py_LeaveRecursiveCallPy(tstate);
            _PyInterpreterFrame *gen_frame = frame;
            frame = cframe.current_frame = frame->previous;
            gen_frame->previous = NULL;
            _PyFrame_StackPush(frame, retval);
            goto resume_frame;
            #line 1388 "Python/generated_cases.c.h"
        }

        TARGET(POP_EXCEPT) {
            PyObject *exc_value = stack_pointer[-1];
            #line 1034 "Python/bytecodes.c"
            _PyErr_StackItem *exc_info = tstate->exc_info;
            Py_XSETREF(exc_info->exc_value, exc_value);
            #line 1396 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(RERAISE) {
            PyObject *exc = stack_pointer[-1];
            PyObject **values = (stack_pointer - (1 + oparg));
            #line 1039 "Python/bytecodes.c"
            assert(oparg >= 0 && oparg <= 2);
            if (oparg) {
                PyObject *lasti = values[0];
                if (PyLong_Check(lasti)) {
                    frame->prev_instr = _PyCode_CODE(_PyFrame_GetCode(frame)) + PyLong_AsLong(lasti);
                    assert(!_PyErr_Occurred(tstate));
                }
                else {
                    assert(PyLong_Check(lasti));
                    _PyErr_SetString(tstate, PyExc_SystemError, "lasti is not an int");
                    goto error;
                }
            }
            assert(exc && PyExceptionInstance_Check(exc));
            Py_INCREF(exc);
            _PyErr_SetRaisedException(tstate, exc);
            goto exception_unwind;
            #line 1422 "Python/generated_cases.c.h"
        }

        TARGET(END_ASYNC_FOR) {
            PyObject *exc = stack_pointer[-1];
            PyObject *awaitable = stack_pointer[-2];
            #line 1059 "Python/bytecodes.c"
            assert(exc && PyExceptionInstance_Check(exc));
            if (PyErr_GivenExceptionMatches(exc, PyExc_StopAsyncIteration)) {
            #line 1431 "Python/generated_cases.c.h"
                Py_DECREF(awaitable);
                Py_DECREF(exc);
            #line 1062 "Python/bytecodes.c"
            }
            else {
                Py_INCREF(exc);
                _PyErr_SetRaisedException(tstate, exc);
                goto exception_unwind;
            }
            #line 1441 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(CLEANUP_THROW) {
            PyObject *exc_value = stack_pointer[-1];
            PyObject *last_sent_val = stack_pointer[-2];
            PyObject *sub_iter = stack_pointer[-3];
            PyObject *none;
            PyObject *value;
            #line 1071 "Python/bytecodes.c"
            assert(throwflag);
            assert(exc_value && PyExceptionInstance_Check(exc_value));
            if (PyErr_GivenExceptionMatches(exc_value, PyExc_StopIteration)) {
                value = Py_NewRef(((PyStopIterationObject *)exc_value)->value);
            #line 1457 "Python/generated_cases.c.h"
                Py_DECREF(sub_iter);
                Py_DECREF(last_sent_val);
                Py_DECREF(exc_value);
            #line 1076 "Python/bytecodes.c"
                none = Py_None;
            }
            else {
                _PyErr_SetRaisedException(tstate, Py_NewRef(exc_value));
                goto exception_unwind;
            }
            #line 1468 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = value;
            stack_pointer[-2] = none;
            DISPATCH();
        }

        TARGET(LOAD_ASSERTION_ERROR) {
            PyObject *value;
            #line 1085 "Python/bytecodes.c"
            value = Py_NewRef(PyExc_AssertionError);
            #line 1479 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(LOAD_BUILD_CLASS) {
            PyObject *bc;
            #line 1089 "Python/bytecodes.c"
            if (PyDict_CheckExact(BUILTINS())) {
                bc = _PyDict_GetItemWithError(BUILTINS(),
                                              &_Py_ID(__build_class__));
                if (bc == NULL) {
                    if (!_PyErr_Occurred(tstate)) {
                        _PyErr_SetString(tstate, PyExc_NameError,
                                         "__build_class__ not found");
                    }
                    if (true) goto error;
                }
                Py_INCREF(bc);
            }
            else {
                bc = PyObject_GetItem(BUILTINS(), &_Py_ID(__build_class__));
                if (bc == NULL) {
                    if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError))
                        _PyErr_SetString(tstate, PyExc_NameError,
                                         "__build_class__ not found");
                    if (true) goto error;
                }
            }
            #line 1509 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = bc;
            DISPATCH();
        }

        TARGET(STORE_NAME) {
            PyObject *v = stack_pointer[-1];
            #line 1114 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when storing %R", name);
            #line 1524 "Python/generated_cases.c.h"
                Py_DECREF(v);
            #line 1121 "Python/bytecodes.c"
                if (true) goto pop_1_error;
            }
            if (PyDict_CheckExact(ns))
                err = PyDict_SetItem(ns, name, v);
            else
                err = PyObject_SetItem(ns, name, v);
            #line 1533 "Python/generated_cases.c.h"
            Py_DECREF(v);
            #line 1128 "Python/bytecodes.c"
            if (err) goto pop_1_error;
            #line 1537 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(DELETE_NAME) {
            #line 1132 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            PyObject *ns = LOCALS();
            int err;
            if (ns == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals when deleting %R", name);
                goto error;
            }
            err = PyObject_DelItem(ns, name);
            // Can't use ERROR_IF here.
            if (err != 0) {
                format_exc_check_arg(tstate, PyExc_NameError,
                                     NAME_ERROR_MSG,
                                     name);
                goto error;
            }
            #line 1560 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(UNPACK_SEQUENCE) {
            PREDICTED(UNPACK_SEQUENCE);
            static_assert(INLINE_CACHE_ENTRIES_UNPACK_SEQUENCE == 1, "incorrect cache size");
            PyObject *seq = stack_pointer[-1];
            #line 1158 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyUnpackSequenceCache *cache = (_PyUnpackSequenceCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_UnpackSequence(seq, next_instr, oparg);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(UNPACK_SEQUENCE, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            PyObject **top = stack_pointer + oparg - 1;
            int res = unpack_iterable(tstate, seq, oparg, -1, top);
            #line 1581 "Python/generated_cases.c.h"
            Py_DECREF(seq);
            #line 1171 "Python/bytecodes.c"
            if (res == 0) goto pop_1_error;
            #line 1585 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(UNPACK_SEQUENCE_TWO_TUPLE) {
            PyObject *seq = stack_pointer[-1];
            PyObject **values = stack_pointer - (1);
            #line 1175 "Python/bytecodes.c"
            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);
            DEOPT_IF(PyTuple_GET_SIZE(seq) != 2, UNPACK_SEQUENCE);
            assert(oparg == 2);
            STAT_INC(UNPACK_SEQUENCE, hit);
            values[0] = Py_NewRef(PyTuple_GET_ITEM(seq, 1));
            values[1] = Py_NewRef(PyTuple_GET_ITEM(seq, 0));
            #line 1602 "Python/generated_cases.c.h"
            Py_DECREF(seq);
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(UNPACK_SEQUENCE_TUPLE) {
            PyObject *seq = stack_pointer[-1];
            PyObject **values = stack_pointer - (1);
            #line 1185 "Python/bytecodes.c"
            DEOPT_IF(!PyTuple_CheckExact(seq), UNPACK_SEQUENCE);
            DEOPT_IF(PyTuple_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyTuple_ITEMS(seq);
            for (int i = oparg; --i >= 0; ) {
                *values++ = Py_NewRef(items[i]);
            }
            #line 1621 "Python/generated_cases.c.h"
            Py_DECREF(seq);
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(UNPACK_SEQUENCE_LIST) {
            PyObject *seq = stack_pointer[-1];
            PyObject **values = stack_pointer - (1);
            #line 1196 "Python/bytecodes.c"
            DEOPT_IF(!PyList_CheckExact(seq), UNPACK_SEQUENCE);
            DEOPT_IF(PyList_GET_SIZE(seq) != oparg, UNPACK_SEQUENCE);
            STAT_INC(UNPACK_SEQUENCE, hit);
            PyObject **items = _PyList_ITEMS(seq);
            for (int i = oparg; --i >= 0; ) {
                *values++ = Py_NewRef(items[i]);
            }
            #line 1640 "Python/generated_cases.c.h"
            Py_DECREF(seq);
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            next_instr += 1;
            DISPATCH();
        }

        TARGET(UNPACK_EX) {
            PyObject *seq = stack_pointer[-1];
            #line 1207 "Python/bytecodes.c"
            int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);
            PyObject **top = stack_pointer + totalargs - 1;
            int res = unpack_iterable(tstate, seq, oparg & 0xFF, oparg >> 8, top);
            #line 1654 "Python/generated_cases.c.h"
            Py_DECREF(seq);
            #line 1211 "Python/bytecodes.c"
            if (res == 0) goto pop_1_error;
            #line 1658 "Python/generated_cases.c.h"
            STACK_GROW((oparg & 0xFF) + (oparg >> 8));
            DISPATCH();
        }

        TARGET(STORE_ATTR) {
            PREDICTED(STORE_ATTR);
            static_assert(INLINE_CACHE_ENTRIES_STORE_ATTR == 4, "incorrect cache size");
            PyObject *owner = stack_pointer[-1];
            PyObject *v = stack_pointer[-2];
            uint16_t counter = read_u16(&next_instr[0].cache);
            #line 1222 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            if (ADAPTIVE_COUNTER_IS_ZERO(counter)) {
                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
                next_instr--;
                _Py_Specialize_StoreAttr(owner, next_instr, name);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(STORE_ATTR, deferred);
            _PyAttrCache *cache = (_PyAttrCache *)next_instr;
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #else
            (void)counter;  // Unused.
            #endif  /* ENABLE_SPECIALIZATION */
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyObject_SetAttr(owner, name, v);
            #line 1685 "Python/generated_cases.c.h"
            Py_DECREF(v);
            Py_DECREF(owner);
            #line 1238 "Python/bytecodes.c"
            if (err) goto pop_2_error;
            #line 1690 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            next_instr += 4;
            DISPATCH();
        }

        TARGET(DELETE_ATTR) {
            PyObject *owner = stack_pointer[-1];
            #line 1242 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyObject_SetAttr(owner, name, (PyObject *)NULL);
            #line 1701 "Python/generated_cases.c.h"
            Py_DECREF(owner);
            #line 1245 "Python/bytecodes.c"
            if (err) goto pop_1_error;
            #line 1705 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(STORE_GLOBAL) {
            PyObject *v = stack_pointer[-1];
            #line 1249 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err = PyDict_SetItem(GLOBALS(), name, v);
            #line 1715 "Python/generated_cases.c.h"
            Py_DECREF(v);
            #line 1252 "Python/bytecodes.c"
            if (err) goto pop_1_error;
            #line 1719 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(DELETE_GLOBAL) {
            #line 1256 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            int err;
            err = PyDict_DelItem(GLOBALS(), name);
            // Can't use ERROR_IF here.
            if (err != 0) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                    format_exc_check_arg(tstate, PyExc_NameError,
                                         NAME_ERROR_MSG, name);
                }
                goto error;
            }
            #line 1737 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(LOAD_LOCALS) {
            PyObject *_tmp_1;
            {
                PyObject *locals;
                #line 1270 "Python/bytecodes.c"
                locals = LOCALS();
                if (locals == NULL) {
                    _PyErr_SetString(tstate, PyExc_SystemError,
                                     "no locals found");
                    if (true) goto error;
                }
                Py_INCREF(locals);
                #line 1753 "Python/generated_cases.c.h"
                _tmp_1 = locals;
            }
            STACK_GROW(1);
            stack_pointer[-1] = _tmp_1;
            DISPATCH();
        }

        TARGET(LOAD_NAME) {
            PyObject *_tmp_1;
            {
                PyObject *locals;
                #line 1270 "Python/bytecodes.c"
                locals = LOCALS();
                if (locals == NULL) {
                    _PyErr_SetString(tstate, PyExc_SystemError,
                                     "no locals found");
                    if (true) goto error;
                }
                Py_INCREF(locals);
                #line 1773 "Python/generated_cases.c.h"
                _tmp_1 = locals;
            }
            {
                PyObject *mod_or_class_dict = _tmp_1;
                PyObject *v;
                #line 1282 "Python/bytecodes.c"
                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
                if (PyDict_CheckExact(mod_or_class_dict)) {
                    v = PyDict_GetItemWithError(mod_or_class_dict, name);
                    if (v != NULL) {
                        Py_INCREF(v);
                    }
                    else if (_PyErr_Occurred(tstate)) {
                        Py_DECREF(mod_or_class_dict);
                        goto error;
                    }
                }
                else {
                    v = PyObject_GetItem(mod_or_class_dict, name);
                    if (v == NULL) {
                        if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                            Py_DECREF(mod_or_class_dict);
                            goto error;
                        }
                        _PyErr_Clear(tstate);
                    }
                }
                Py_DECREF(mod_or_class_dict);
                if (v == NULL) {
                    v = PyDict_GetItemWithError(GLOBALS(), name);
                    if (v != NULL) {
                        Py_INCREF(v);
                    }
                    else if (_PyErr_Occurred(tstate)) {
                        goto error;
                    }
                    else {
                        if (PyDict_CheckExact(BUILTINS())) {
                            v = PyDict_GetItemWithError(BUILTINS(), name);
                            if (v == NULL) {
                                if (!_PyErr_Occurred(tstate)) {
                                    format_exc_check_arg(
                                            tstate, PyExc_NameError,
                                            NAME_ERROR_MSG, name);
                                }
                                goto error;
                            }
                            Py_INCREF(v);
                        }
                        else {
                            v = PyObject_GetItem(BUILTINS(), name);
                            if (v == NULL) {
                                if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                                    format_exc_check_arg(
                                                tstate, PyExc_NameError,
                                                NAME_ERROR_MSG, name);
                                }
                                goto error;
                            }
                        }
                    }
                }
                #line 1836 "Python/generated_cases.c.h"
                _tmp_1 = v;
            }
            STACK_GROW(1);
            stack_pointer[-1] = _tmp_1;
            DISPATCH();
        }

        TARGET(LOAD_FROM_DICT_OR_GLOBALS) {
            PyObject *_tmp_1 = stack_pointer[-1];
            {
                PyObject *mod_or_class_dict = _tmp_1;
                PyObject *v;
                #line 1282 "Python/bytecodes.c"
                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
                if (PyDict_CheckExact(mod_or_class_dict)) {
                    v = PyDict_GetItemWithError(mod_or_class_dict, name);
                    if (v != NULL) {
                        Py_INCREF(v);
                    }
                    else if (_PyErr_Occurred(tstate)) {
                        Py_DECREF(mod_or_class_dict);
                        goto error;
                    }
                }
                else {
                    v = PyObject_GetItem(mod_or_class_dict, name);
                    if (v == NULL) {
                        if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                            Py_DECREF(mod_or_class_dict);
                            goto error;
                        }
                        _PyErr_Clear(tstate);
                    }
                }
                Py_DECREF(mod_or_class_dict);
                if (v == NULL) {
                    v = PyDict_GetItemWithError(GLOBALS(), name);
                    if (v != NULL) {
                        Py_INCREF(v);
                    }
                    else if (_PyErr_Occurred(tstate)) {
                        goto error;
                    }
                    else {
                        if (PyDict_CheckExact(BUILTINS())) {
                            v = PyDict_GetItemWithError(BUILTINS(), name);
                            if (v == NULL) {
                                if (!_PyErr_Occurred(tstate)) {
                                    format_exc_check_arg(
                                            tstate, PyExc_NameError,
                                            NAME_ERROR_MSG, name);
                                }
                                goto error;
                            }
                            Py_INCREF(v);
                        }
                        else {
                            v = PyObject_GetItem(BUILTINS(), name);
                            if (v == NULL) {
                                if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                                    format_exc_check_arg(
                                                tstate, PyExc_NameError,
                                                NAME_ERROR_MSG, name);
                                }
                                goto error;
                            }
                        }
                    }
                }
                #line 1906 "Python/generated_cases.c.h"
                _tmp_1 = v;
            }
            stack_pointer[-1] = _tmp_1;
            DISPATCH();
        }

        TARGET(LOAD_GLOBAL) {
            PREDICTED(LOAD_GLOBAL);
            static_assert(INLINE_CACHE_ENTRIES_LOAD_GLOBAL == 4, "incorrect cache size");
            PyObject *null = NULL;
            PyObject *v;
            #line 1351 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyLoadGlobalCache *cache = (_PyLoadGlobalCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
                next_instr--;
                _Py_Specialize_LoadGlobal(GLOBALS(), BUILTINS(), next_instr, name);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(LOAD_GLOBAL, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            if (PyDict_CheckExact(GLOBALS())
                && PyDict_CheckExact(BUILTINS()))
            {
                v = _PyDict_LoadGlobal((PyDictObject *)GLOBALS(),
                                       (PyDictObject *)BUILTINS(),
                                       name);
                if (v == NULL) {
                    if (!_PyErr_Occurred(tstate)) {
                        /* _PyDict_LoadGlobal() returns NULL without raising
                         * an exception if the key doesn't exist */
                        format_exc_check_arg(tstate, PyExc_NameError,
                                             NAME_ERROR_MSG, name);
                    }
                    if (true) goto error;
                }
                Py_INCREF(v);
            }
            else {
                /* Slow-path if globals or builtins is not a dict */

                /* namespace 1: globals */
                v = PyObject_GetItem(GLOBALS(), name);
                if (v == NULL) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) goto error;
                    _PyErr_Clear(tstate);

                    /* namespace 2: builtins */
                    v = PyObject_GetItem(BUILTINS(), name);
                    if (v == NULL) {
                        if (_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                            format_exc_check_arg(
                                        tstate, PyExc_NameError,
                                        NAME_ERROR_MSG, name);
                        }
                        if (true) goto error;
                    }
                }
            }
            null = NULL;
            #line 1970 "Python/generated_cases.c.h"
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = v;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = null; }
            next_instr += 4;
            DISPATCH();
        }

        TARGET(LOAD_GLOBAL_MODULE) {
            PyObject *null = NULL;
            PyObject *res;
            uint16_t index = read_u16(&next_instr[1].cache);
            uint16_t version = read_u16(&next_instr[2].cache);
            #line 1405 "Python/bytecodes.c"
            DEOPT_IF(!PyDict_CheckExact(GLOBALS()), LOAD_GLOBAL);
            PyDictObject *dict = (PyDictObject *)GLOBALS();
            DEOPT_IF(dict->ma_keys->dk_version != version, LOAD_GLOBAL);
            assert(DK_IS_UNICODE(dict->ma_keys));
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(dict->ma_keys);
            res = entries[index].me_value;
            DEOPT_IF(res == NULL, LOAD_GLOBAL);
            Py_INCREF(res);
            STAT_INC(LOAD_GLOBAL, hit);
            null = NULL;
            #line 1995 "Python/generated_cases.c.h"
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = null; }
            next_instr += 4;
            DISPATCH();
        }

        TARGET(LOAD_GLOBAL_BUILTIN) {
            PyObject *null = NULL;
            PyObject *res;
            uint16_t index = read_u16(&next_instr[1].cache);
            uint16_t mod_version = read_u16(&next_instr[2].cache);
            uint16_t bltn_version = read_u16(&next_instr[3].cache);
            #line 1418 "Python/bytecodes.c"
            DEOPT_IF(!PyDict_CheckExact(GLOBALS()), LOAD_GLOBAL);
            DEOPT_IF(!PyDict_CheckExact(BUILTINS()), LOAD_GLOBAL);
            PyDictObject *mdict = (PyDictObject *)GLOBALS();
            PyDictObject *bdict = (PyDictObject *)BUILTINS();
            assert(opcode == LOAD_GLOBAL_BUILTIN);
            DEOPT_IF(mdict->ma_keys->dk_version != mod_version, LOAD_GLOBAL);
            DEOPT_IF(bdict->ma_keys->dk_version != bltn_version, LOAD_GLOBAL);
            assert(DK_IS_UNICODE(bdict->ma_keys));
            PyDictUnicodeEntry *entries = DK_UNICODE_ENTRIES(bdict->ma_keys);
            res = entries[index].me_value;
            DEOPT_IF(res == NULL, LOAD_GLOBAL);
            Py_INCREF(res);
            STAT_INC(LOAD_GLOBAL, hit);
            null = NULL;
            #line 2025 "Python/generated_cases.c.h"
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = null; }
            next_instr += 4;
            DISPATCH();
        }

        TARGET(DELETE_FAST) {
            #line 1435 "Python/bytecodes.c"
            PyObject *v = GETLOCAL(oparg);
            if (v == NULL) goto unbound_local_error;
            SETLOCAL(oparg, NULL);
            #line 2039 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(MAKE_CELL) {
            #line 1441 "Python/bytecodes.c"
            // "initial" is probably NULL but not if it's an arg (or set
            // via PyFrame_LocalsToFast() before MAKE_CELL has run).
            PyObject *initial = GETLOCAL(oparg);
            PyObject *cell = PyCell_New(initial);
            if (cell == NULL) {
                goto resume_with_error;
            }
            SETLOCAL(oparg, cell);
            #line 2053 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(DELETE_DEREF) {
            #line 1452 "Python/bytecodes.c"
            PyObject *cell = GETLOCAL(oparg);
            PyObject *oldobj = PyCell_GET(cell);
            // Can't use ERROR_IF here.
            // Fortunately we don't need its superpower.
            if (oldobj == NULL) {
                format_exc_unbound(tstate, _PyFrame_GetCode(frame), oparg);
                goto error;
            }
            PyCell_SET(cell, NULL);
            Py_DECREF(oldobj);
            #line 2069 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(LOAD_FROM_DICT_OR_DEREF) {
            PyObject *class_dict = stack_pointer[-1];
            PyObject *value;
            #line 1465 "Python/bytecodes.c"
            PyObject *name;
            assert(class_dict);
            assert(oparg >= 0 && oparg < _PyFrame_GetCode(frame)->co_nlocalsplus);
            name = PyTuple_GET_ITEM(_PyFrame_GetCode(frame)->co_localsplusnames, oparg);
            if (PyDict_CheckExact(class_dict)) {
                value = PyDict_GetItemWithError(class_dict, name);
                if (value != NULL) {
                    Py_INCREF(value);
                }
                else if (_PyErr_Occurred(tstate)) {
                    Py_DECREF(class_dict);
                    goto error;
                }
            }
            else {
                value = PyObject_GetItem(class_dict, name);
                if (value == NULL) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) {
                        Py_DECREF(class_dict);
                        goto error;
                    }
                    _PyErr_Clear(tstate);
                }
            }
            Py_DECREF(class_dict);
            if (!value) {
                PyObject *cell = GETLOCAL(oparg);
                value = PyCell_GET(cell);
                if (value == NULL) {
                    format_exc_unbound(tstate, _PyFrame_GetCode(frame), oparg);
                    goto error;
                }
                Py_INCREF(value);
            }
            #line 2111 "Python/generated_cases.c.h"
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(LOAD_DEREF) {
            PyObject *value;
            #line 1502 "Python/bytecodes.c"
            PyObject *cell = GETLOCAL(oparg);
            value = PyCell_GET(cell);
            if (value == NULL) {
                format_exc_unbound(tstate, _PyFrame_GetCode(frame), oparg);
                if (true) goto error;
            }
            Py_INCREF(value);
            #line 2126 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = value;
            DISPATCH();
        }

        TARGET(STORE_DEREF) {
            PyObject *v = stack_pointer[-1];
            #line 1512 "Python/bytecodes.c"
            PyObject *cell = GETLOCAL(oparg);
            PyObject *oldobj = PyCell_GET(cell);
            PyCell_SET(cell, v);
            Py_XDECREF(oldobj);
            #line 2139 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(COPY_FREE_VARS) {
            #line 1519 "Python/bytecodes.c"
            /* Copy closure variables to free variables */
            PyCodeObject *co = _PyFrame_GetCode(frame);
            assert(PyFunction_Check(frame->f_funcobj));
            PyObject *closure = ((PyFunctionObject *)frame->f_funcobj)->func_closure;
            assert(oparg == co->co_nfreevars);
            int offset = co->co_nlocalsplus - oparg;
            for (int i = 0; i < oparg; ++i) {
                PyObject *o = PyTuple_GET_ITEM(closure, i);
                frame->localsplus[offset + i] = Py_NewRef(o);
            }
            #line 2156 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(BUILD_STRING) {
            PyObject **pieces = (stack_pointer - oparg);
            PyObject *str;
            #line 1532 "Python/bytecodes.c"
            str = _PyUnicode_JoinArray(&_Py_STR(empty), pieces, oparg);
            #line 2165 "Python/generated_cases.c.h"
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF(pieces[_i]);
            }
            #line 1534 "Python/bytecodes.c"
            if (str == NULL) { STACK_SHRINK(oparg); goto error; }
            #line 2171 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            stack_pointer[-1] = str;
            DISPATCH();
        }

        TARGET(BUILD_TUPLE) {
            PyObject **values = (stack_pointer - oparg);
            PyObject *tup;
            #line 1538 "Python/bytecodes.c"
            tup = _PyTuple_FromArraySteal(values, oparg);
            if (tup == NULL) { STACK_SHRINK(oparg); goto error; }
            #line 2184 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            stack_pointer[-1] = tup;
            DISPATCH();
        }

        TARGET(BUILD_LIST) {
            PyObject **values = (stack_pointer - oparg);
            PyObject *list;
            #line 1543 "Python/bytecodes.c"
            list = _PyList_FromArraySteal(values, oparg);
            if (list == NULL) { STACK_SHRINK(oparg); goto error; }
            #line 2197 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            stack_pointer[-1] = list;
            DISPATCH();
        }

        TARGET(LIST_EXTEND) {
            PyObject *iterable = stack_pointer[-1];
            PyObject *list = stack_pointer[-(2 + (oparg-1))];
            #line 1548 "Python/bytecodes.c"
            PyObject *none_val = _PyList_Extend((PyListObject *)list, iterable);
            if (none_val == NULL) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_TypeError) &&
                   (Py_TYPE(iterable)->tp_iter == NULL && !PySequence_Check(iterable)))
                {
                    _PyErr_Clear(tstate);
                    _PyErr_Format(tstate, PyExc_TypeError,
                          "Value after * must be an iterable, not %.200s",
                          Py_TYPE(iterable)->tp_name);
                }
            #line 2218 "Python/generated_cases.c.h"
                Py_DECREF(iterable);
            #line 1559 "Python/bytecodes.c"
                if (true) goto pop_1_error;
            }
            assert(Py_IsNone(none_val));
            #line 2224 "Python/generated_cases.c.h"
            Py_DECREF(iterable);
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(SET_UPDATE) {
            PyObject *iterable = stack_pointer[-1];
            PyObject *set = stack_pointer[-(2 + (oparg-1))];
            #line 1566 "Python/bytecodes.c"
            int err = _PySet_Update(set, iterable);
            #line 2235 "Python/generated_cases.c.h"
            Py_DECREF(iterable);
            #line 1568 "Python/bytecodes.c"
            if (err < 0) goto pop_1_error;
            #line 2239 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(BUILD_SET) {
            PyObject **values = (stack_pointer - oparg);
            PyObject *set;
            #line 1572 "Python/bytecodes.c"
            set = PySet_New(NULL);
            if (set == NULL)
                goto error;
            int err = 0;
            for (int i = 0; i < oparg; i++) {
                PyObject *item = values[i];
                if (err == 0)
                    err = PySet_Add(set, item);
                Py_DECREF(item);
            }
            if (err != 0) {
                Py_DECREF(set);
                if (true) { STACK_SHRINK(oparg); goto error; }
            }
            #line 2262 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            stack_pointer[-1] = set;
            DISPATCH();
        }

        TARGET(BUILD_MAP) {
            PyObject **values = (stack_pointer - oparg*2);
            PyObject *map;
            #line 1589 "Python/bytecodes.c"
            map = _PyDict_FromItems(
                    values, 2,
                    values+1, 2,
                    oparg);
            if (map == NULL)
                goto error;

            #line 2280 "Python/generated_cases.c.h"
            for (int _i = oparg*2; --_i >= 0;) {
                Py_DECREF(values[_i]);
            }
            #line 1597 "Python/bytecodes.c"
            if (map == NULL) { STACK_SHRINK(oparg*2); goto error; }
            #line 2286 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg*2);
            STACK_GROW(1);
            stack_pointer[-1] = map;
            DISPATCH();
        }

        TARGET(SETUP_ANNOTATIONS) {
            #line 1601 "Python/bytecodes.c"
            int err;
            PyObject *ann_dict;
            if (LOCALS() == NULL) {
                _PyErr_Format(tstate, PyExc_SystemError,
                              "no locals found when setting up annotations");
                if (true) goto error;
            }
            /* check if __annotations__ in locals()... */
            if (PyDict_CheckExact(LOCALS())) {
                ann_dict = _PyDict_GetItemWithError(LOCALS(),
                                                    &_Py_ID(__annotations__));
                if (ann_dict == NULL) {
                    if (_PyErr_Occurred(tstate)) goto error;
                    /* ...if not, create a new one */
                    ann_dict = PyDict_New();
                    if (ann_dict == NULL) goto error;
                    err = PyDict_SetItem(LOCALS(), &_Py_ID(__annotations__),
                                         ann_dict);
                    Py_DECREF(ann_dict);
                    if (err) goto error;
                }
            }
            else {
                /* do the same if locals() is not a dict */
                ann_dict = PyObject_GetItem(LOCALS(), &_Py_ID(__annotations__));
                if (ann_dict == NULL) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_KeyError)) goto error;
                    _PyErr_Clear(tstate);
                    ann_dict = PyDict_New();
                    if (ann_dict == NULL) goto error;
                    err = PyObject_SetItem(LOCALS(), &_Py_ID(__annotations__),
                                           ann_dict);
                    Py_DECREF(ann_dict);
                    if (err) goto error;
                }
                else {
                    Py_DECREF(ann_dict);
                }
            }
            #line 2334 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(BUILD_CONST_KEY_MAP) {
            PyObject *keys = stack_pointer[-1];
            PyObject **values = (stack_pointer - (1 + oparg));
            PyObject *map;
            #line 1643 "Python/bytecodes.c"
            if (!PyTuple_CheckExact(keys) ||
                PyTuple_GET_SIZE(keys) != (Py_ssize_t)oparg) {
                _PyErr_SetString(tstate, PyExc_SystemError,
                                 "bad BUILD_CONST_KEY_MAP keys argument");
                goto error;  // Pop the keys and values.
            }
            map = _PyDict_FromItems(
                    &PyTuple_GET_ITEM(keys, 0), 1,
                    values, 1, oparg);
            #line 2352 "Python/generated_cases.c.h"
            for (int _i = oparg; --_i >= 0;) {
                Py_DECREF(values[_i]);
            }
            Py_DECREF(keys);
            #line 1653 "Python/bytecodes.c"
            if (map == NULL) { STACK_SHRINK(oparg); goto pop_1_error; }
            #line 2359 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            stack_pointer[-1] = map;
            DISPATCH();
        }

        TARGET(DICT_UPDATE) {
            PyObject *update = stack_pointer[-1];
            #line 1657 "Python/bytecodes.c"
            PyObject *dict = PEEK(oparg + 1);  // update is still on the stack
            if (PyDict_Update(dict, update) < 0) {
                if (_PyErr_ExceptionMatches(tstate, PyExc_AttributeError)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                    "'%.200s' object is not a mapping",
                                    Py_TYPE(update)->tp_name);
                }
            #line 2375 "Python/generated_cases.c.h"
                Py_DECREF(update);
            #line 1665 "Python/bytecodes.c"
                if (true) goto pop_1_error;
            }
            #line 2380 "Python/generated_cases.c.h"
            Py_DECREF(update);
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(DICT_MERGE) {
            PyObject *update = stack_pointer[-1];
            #line 1671 "Python/bytecodes.c"
            PyObject *dict = PEEK(oparg + 1);  // update is still on the stack

            if (_PyDict_MergeEx(dict, update, 2) < 0) {
                format_kwargs_error(tstate, PEEK(3 + oparg), update);
            #line 2393 "Python/generated_cases.c.h"
                Py_DECREF(update);
            #line 1676 "Python/bytecodes.c"
                if (true) goto pop_1_error;
            }
            #line 2398 "Python/generated_cases.c.h"
            Py_DECREF(update);
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(MAP_ADD) {
            PyObject *value = stack_pointer[-1];
            PyObject *key = stack_pointer[-2];
            #line 1682 "Python/bytecodes.c"
            PyObject *dict = PEEK(oparg + 2);  // key, value are still on the stack
            assert(PyDict_CheckExact(dict));
            /* dict[key] = value */
            // Do not DECREF INPUTS because the function steals the references
            if (_PyDict_SetItem_Take2((PyDictObject *)dict, key, value) != 0) goto pop_2_error;
            #line 2413 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            DISPATCH();
        }

        TARGET(INSTRUMENTED_LOAD_SUPER_ATTR) {
            #line 1690 "Python/bytecodes.c"
            _PySuperAttrCache *cache = (_PySuperAttrCache *)next_instr;
            // cancel out the decrement that will happen in LOAD_SUPER_ATTR; we
            // don't want to specialize instrumented instructions
            INCREMENT_ADAPTIVE_COUNTER(cache->counter);
            GO_TO_INSTRUCTION(LOAD_SUPER_ATTR);
            #line 2425 "Python/generated_cases.c.h"
        }

        TARGET(LOAD_SUPER_ATTR) {
            PREDICTED(LOAD_SUPER_ATTR);
            static_assert(INLINE_CACHE_ENTRIES_LOAD_SUPER_ATTR == 1, "incorrect cache size");
            PyObject *self = stack_pointer[-1];
            PyObject *class = stack_pointer[-2];
            PyObject *global_super = stack_pointer[-3];
            PyObject *res2 = NULL;
            PyObject *res;
            #line 1704 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            int load_method = oparg & 1;
            #if ENABLE_SPECIALIZATION
            _PySuperAttrCache *cache = (_PySuperAttrCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_LoadSuperAttr(global_super, class, next_instr, load_method);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(LOAD_SUPER_ATTR, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */

            if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {
                PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;
                int err = _Py_call_instrumentation_2args(
                        tstate, PY_MONITORING_EVENT_CALL,
                        frame, next_instr-1, global_super, arg);
                if (err) goto pop_3_error;
            }

            // we make no attempt to optimize here; specializations should
            // handle any case whose performance we care about
            PyObject *stack[] = {class, self};
            PyObject *super = PyObject_Vectorcall(global_super, stack, oparg & 2, NULL);
            if (opcode == INSTRUMENTED_LOAD_SUPER_ATTR) {
                PyObject *arg = oparg & 2 ? class : &_PyInstrumentation_MISSING;
                if (super == NULL) {
                    _Py_call_instrumentation_exc2(
                        tstate, PY_MONITORING_EVENT_C_RAISE,
                        frame, next_instr-1, global_super, arg);
                }
                else {
                    int err = _Py_call_instrumentation_2args(
                        tstate, PY_MONITORING_EVENT_C_RETURN,
                        frame, next_instr-1, global_super, arg);
                    if (err < 0) {
                        Py_CLEAR(super);
                    }
                }
            }
            #line 2478 "Python/generated_cases.c.h"
            Py_DECREF(global_super);
            Py_DECREF(class);
            Py_DECREF(self);
            #line 1746 "Python/bytecodes.c"
            if (super == NULL) goto pop_3_error;
            res = PyObject_GetAttr(super, name);
            Py_DECREF(super);
            if (res == NULL) goto pop_3_error;
            #line 2487 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 1;
            DISPATCH();
        }

        TARGET(LOAD_SUPER_ATTR_ATTR) {
            PyObject *self = stack_pointer[-1];
            PyObject *class = stack_pointer[-2];
            PyObject *global_super = stack_pointer[-3];
            PyObject *res2 = NULL;
            PyObject *res;
            #line 1765 "Python/bytecodes.c"
            assert(!(oparg & 1));
            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);
            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            res = _PySuper_Lookup((PyTypeObject *)class, self, name, NULL);
            #line 2509 "Python/generated_cases.c.h"
            Py_DECREF(global_super);
            Py_DECREF(class);
            Py_DECREF(self);
            #line 1772 "Python/bytecodes.c"
            if (res == NULL) goto pop_3_error;
            #line 2515 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 1;
            DISPATCH();
        }

        TARGET(LOAD_SUPER_ATTR_METHOD) {
            PyObject *self = stack_pointer[-1];
            PyObject *class = stack_pointer[-2];
            PyObject *global_super = stack_pointer[-3];
            PyObject *res2;
            PyObject *res;
            #line 1776 "Python/bytecodes.c"
            assert(oparg & 1);
            DEOPT_IF(global_super != (PyObject *)&PySuper_Type, LOAD_SUPER_ATTR);
            DEOPT_IF(!PyType_Check(class), LOAD_SUPER_ATTR);
            STAT_INC(LOAD_SUPER_ATTR, hit);
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 2);
            PyTypeObject *cls = (PyTypeObject *)class;
            int method_found = 0;
            res2 = _PySuper_Lookup(cls, self, name,
                                   cls->tp_getattro == PyObject_GenericGetAttr ? &method_found : NULL);
            Py_DECREF(global_super);
            Py_DECREF(class);
            if (res2 == NULL) {
                Py_DECREF(self);
                if (true) goto pop_3_error;
            }
            if (method_found) {
                res = self; // transfer ownership
            } else {
                Py_DECREF(self);
                res = res2;
                res2 = NULL;
            }
            #line 2553 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            stack_pointer[-2] = res2;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(LOAD_ATTR) {
            PREDICTED(LOAD_ATTR);
            static_assert(INLINE_CACHE_ENTRIES_LOAD_ATTR == 9, "incorrect cache size");
            PyObject *owner = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            #line 1815 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyAttrCache *cache = (_PyAttrCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
                next_instr--;
                _Py_Specialize_LoadAttr(owner, next_instr, name);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(LOAD_ATTR, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);
            if (oparg & 1) {
                /* Designed to work in tandem with CALL, pushes two values. */
                PyObject* meth = NULL;
                if (_PyObject_GetMethod(owner, name, &meth)) {
                    /* We can bypass temporary bound method object.
                       meth is unbound method and obj is self.

                       meth | self | arg1 | ... | argN
                     */
                    assert(meth != NULL);  // No errors on this branch
                    res2 = meth;
                    res = owner;  // Transfer ownership
                }
                else {
                    /* meth is not an unbound method (but a regular attr, or
                       something was returned by a descriptor protocol).  Set
                       the second element of the stack to NULL, to signal
                       CALL that it's not a method call.

                       NULL | meth | arg1 | ... | argN
                    */
            #line 2601 "Python/generated_cases.c.h"
                    Py_DECREF(owner);
            #line 1849 "Python/bytecodes.c"
                    if (meth == NULL) goto pop_1_error;
                    res2 = NULL;
                    res = meth;
                }
            }
            else {
                /* Classic, pushes one value. */
                res = PyObject_GetAttr(owner, name);
            #line 2612 "Python/generated_cases.c.h"
                Py_DECREF(owner);
            #line 1858 "Python/bytecodes.c"
                if (res == NULL) goto pop_1_error;
            }
            #line 2617 "Python/generated_cases.c.h"
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_INSTANCE_VALUE) {
            PyObject *owner = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 1867 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);
            assert(tp->tp_dictoffset < 0);
            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), LOAD_ATTR);
            res = _PyDictOrValues_GetValues(dorv)->values[index];
            DEOPT_IF(res == NULL, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(res);
            res2 = NULL;
            #line 2644 "Python/generated_cases.c.h"
            Py_DECREF(owner);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_MODULE) {
            PyObject *owner = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 1883 "Python/bytecodes.c"
            DEOPT_IF(!PyModule_CheckExact(owner), LOAD_ATTR);
            PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;
            assert(dict != NULL);
            DEOPT_IF(dict->ma_keys->dk_version != type_version, LOAD_ATTR);
            assert(dict->ma_keys->dk_kind == DICT_KEYS_UNICODE);
            assert(index < dict->ma_keys->dk_nentries);
            PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + index;
            res = ep->me_value;
            DEOPT_IF(res == NULL, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(res);
            res2 = NULL;
            #line 2672 "Python/generated_cases.c.h"
            Py_DECREF(owner);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_WITH_HINT) {
            PyObject *owner = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 1899 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);
            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
            DEOPT_IF(_PyDictOrValues_IsValues(dorv), LOAD_ATTR);
            PyDictObject *dict = (PyDictObject *)_PyDictOrValues_GetDict(dorv);
            DEOPT_IF(dict == NULL, LOAD_ATTR);
            assert(PyDict_CheckExact((PyObject *)dict));
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg>>1);
            uint16_t hint = index;
            DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, LOAD_ATTR);
            if (DK_IS_UNICODE(dict->ma_keys)) {
                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;
                DEOPT_IF(ep->me_key != name, LOAD_ATTR);
                res = ep->me_value;
            }
            else {
                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;
                DEOPT_IF(ep->me_key != name, LOAD_ATTR);
                res = ep->me_value;
            }
            DEOPT_IF(res == NULL, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(res);
            res2 = NULL;
            #line 2714 "Python/generated_cases.c.h"
            Py_DECREF(owner);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_SLOT) {
            PyObject *owner = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 1929 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, LOAD_ATTR);
            char *addr = (char *)owner + index;
            res = *(PyObject **)addr;
            DEOPT_IF(res == NULL, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(res);
            res2 = NULL;
            #line 2739 "Python/generated_cases.c.h"
            Py_DECREF(owner);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_CLASS) {
            PyObject *cls = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            PyObject *descr = read_obj(&next_instr[5].cache);
            #line 1942 "Python/bytecodes.c"

            DEOPT_IF(!PyType_Check(cls), LOAD_ATTR);
            DEOPT_IF(((PyTypeObject *)cls)->tp_version_tag != type_version,
                LOAD_ATTR);
            assert(type_version != 0);

            STAT_INC(LOAD_ATTR, hit);
            res2 = NULL;
            res = descr;
            assert(res != NULL);
            Py_INCREF(res);
            #line 2766 "Python/generated_cases.c.h"
            Py_DECREF(cls);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_PROPERTY) {
            PyObject *owner = stack_pointer[-1];
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint32_t func_version = read_u32(&next_instr[3].cache);
            PyObject *fget = read_obj(&next_instr[5].cache);
            #line 1957 "Python/bytecodes.c"
            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);

            PyTypeObject *cls = Py_TYPE(owner);
            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);
            assert(type_version != 0);
            assert(Py_IS_TYPE(fget, &PyFunction_Type));
            PyFunctionObject *f = (PyFunctionObject *)fget;
            assert(func_version != 0);
            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);
            PyCodeObject *code = (PyCodeObject *)f->func_code;
            assert(code->co_argcount == 1);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            Py_INCREF(fget);
            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 1);
            // Manipulate stack directly because we exit with DISPATCH_INLINED().
            SET_TOP(NULL);
            int shrink_stack = !(oparg & 1);
            STACK_SHRINK(shrink_stack);
            new_frame->localsplus[0] = owner;
            SKIP_OVER(INLINE_CACHE_ENTRIES_LOAD_ATTR);
            frame->return_offset = 0;
            DISPATCH_INLINED(new_frame);
            #line 2804 "Python/generated_cases.c.h"
        }

        TARGET(LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN) {
            PyObject *owner = stack_pointer[-1];
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint32_t func_version = read_u32(&next_instr[3].cache);
            PyObject *getattribute = read_obj(&next_instr[5].cache);
            #line 1983 "Python/bytecodes.c"
            DEOPT_IF(tstate->interp->eval_frame, LOAD_ATTR);
            PyTypeObject *cls = Py_TYPE(owner);
            DEOPT_IF(cls->tp_version_tag != type_version, LOAD_ATTR);
            assert(type_version != 0);
            assert(Py_IS_TYPE(getattribute, &PyFunction_Type));
            PyFunctionObject *f = (PyFunctionObject *)getattribute;
            assert(func_version != 0);
            DEOPT_IF(f->func_version != func_version, LOAD_ATTR);
            PyCodeObject *code = (PyCodeObject *)f->func_code;
            assert(code->co_argcount == 2);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);

            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg >> 1);
            Py_INCREF(f);
            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, f, 2);
            // Manipulate stack directly because we exit with DISPATCH_INLINED().
            SET_TOP(NULL);
            int shrink_stack = !(oparg & 1);
            STACK_SHRINK(shrink_stack);
            new_frame->localsplus[0] = owner;
            new_frame->localsplus[1] = Py_NewRef(name);
            SKIP_OVER(INLINE_CACHE_ENTRIES_LOAD_ATTR);
            frame->return_offset = 0;
            DISPATCH_INLINED(new_frame);
            #line 2838 "Python/generated_cases.c.h"
        }

        TARGET(STORE_ATTR_INSTANCE_VALUE) {
            PyObject *owner = stack_pointer[-1];
            PyObject *value = stack_pointer[-2];
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 2011 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);
            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), STORE_ATTR);
            STAT_INC(STORE_ATTR, hit);
            PyDictValues *values = _PyDictOrValues_GetValues(dorv);
            PyObject *old_value = values->values[index];
            values->values[index] = value;
            if (old_value == NULL) {
                _PyDictValues_AddToInsertionOrder(values, index);
            }
            else {
                Py_DECREF(old_value);
            }
            Py_DECREF(owner);
            #line 2864 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            next_instr += 4;
            DISPATCH();
        }

        TARGET(STORE_ATTR_WITH_HINT) {
            PyObject *owner = stack_pointer[-1];
            PyObject *value = stack_pointer[-2];
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t hint = read_u16(&next_instr[3].cache);
            #line 2031 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);
            assert(tp->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
            DEOPT_IF(_PyDictOrValues_IsValues(dorv), STORE_ATTR);
            PyDictObject *dict = (PyDictObject *)_PyDictOrValues_GetDict(dorv);
            DEOPT_IF(dict == NULL, STORE_ATTR);
            assert(PyDict_CheckExact((PyObject *)dict));
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            DEOPT_IF(hint >= (size_t)dict->ma_keys->dk_nentries, STORE_ATTR);
            PyObject *old_value;
            uint64_t new_version;
            if (DK_IS_UNICODE(dict->ma_keys)) {
                PyDictUnicodeEntry *ep = DK_UNICODE_ENTRIES(dict->ma_keys) + hint;
                DEOPT_IF(ep->me_key != name, STORE_ATTR);
                old_value = ep->me_value;
                DEOPT_IF(old_value == NULL, STORE_ATTR);
                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);
                ep->me_value = value;
            }
            else {
                PyDictKeyEntry *ep = DK_ENTRIES(dict->ma_keys) + hint;
                DEOPT_IF(ep->me_key != name, STORE_ATTR);
                old_value = ep->me_value;
                DEOPT_IF(old_value == NULL, STORE_ATTR);
                new_version = _PyDict_NotifyEvent(tstate->interp, PyDict_EVENT_MODIFIED, dict, name, value);
                ep->me_value = value;
            }
            Py_DECREF(old_value);
            STAT_INC(STORE_ATTR, hit);
            /* Ensure dict is GC tracked if it needs to be */
            if (!_PyObject_GC_IS_TRACKED(dict) && _PyObject_GC_MAY_BE_TRACKED(value)) {
                _PyObject_GC_TRACK(dict);
            }
            /* PEP 509 */
            dict->ma_version_tag = new_version;
            Py_DECREF(owner);
            #line 2914 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            next_instr += 4;
            DISPATCH();
        }

        TARGET(STORE_ATTR_SLOT) {
            PyObject *owner = stack_pointer[-1];
            PyObject *value = stack_pointer[-2];
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint16_t index = read_u16(&next_instr[3].cache);
            #line 2072 "Python/bytecodes.c"
            PyTypeObject *tp = Py_TYPE(owner);
            assert(type_version != 0);
            DEOPT_IF(tp->tp_version_tag != type_version, STORE_ATTR);
            char *addr = (char *)owner + index;
            STAT_INC(STORE_ATTR, hit);
            PyObject *old_value = *(PyObject **)addr;
            *(PyObject **)addr = value;
            Py_XDECREF(old_value);
            Py_DECREF(owner);
            #line 2935 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            next_instr += 4;
            DISPATCH();
        }

        TARGET(COMPARE_OP) {
            PREDICTED(COMPARE_OP);
            static_assert(INLINE_CACHE_ENTRIES_COMPARE_OP == 1, "incorrect cache size");
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            #line 2091 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyCompareOpCache *cache = (_PyCompareOpCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_CompareOp(left, right, next_instr, oparg);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(COMPARE_OP, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            assert((oparg >> 5) <= Py_GE);
            res = PyObject_RichCompare(left, right, oparg >> 5);
            #line 2960 "Python/generated_cases.c.h"
            Py_DECREF(left);
            Py_DECREF(right);
            #line 2104 "Python/bytecodes.c"
            if (res == NULL) goto pop_2_error;
            if (oparg & 16) {
                int res_bool = PyObject_IsTrue(res);
                Py_DECREF(res);
                if (res_bool < 0) goto pop_2_error;
                res = res_bool ? Py_True : Py_False;
            }
            #line 2971 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(COMPARE_OP_FLOAT) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            #line 2114 "Python/bytecodes.c"
            DEOPT_IF(!PyFloat_CheckExact(left), COMPARE_OP);
            DEOPT_IF(!PyFloat_CheckExact(right), COMPARE_OP);
            STAT_INC(COMPARE_OP, hit);
            double dleft = PyFloat_AS_DOUBLE(left);
            double dright = PyFloat_AS_DOUBLE(right);
            // 1 if NaN, 2 if <, 4 if >, 8 if ==; this matches low four bits of the oparg
            int sign_ish = COMPARISON_BIT(dleft, dright);
            _Py_DECREF_SPECIALIZED(left, _PyFloat_ExactDealloc);
            _Py_DECREF_SPECIALIZED(right, _PyFloat_ExactDealloc);
            res = (sign_ish & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            #line 2994 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(COMPARE_OP_INT) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            #line 2129 "Python/bytecodes.c"
            DEOPT_IF(!PyLong_CheckExact(left), COMPARE_OP);
            DEOPT_IF(!PyLong_CheckExact(right), COMPARE_OP);
            DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)left), COMPARE_OP);
            DEOPT_IF(!_PyLong_IsCompact((PyLongObject *)right), COMPARE_OP);
            STAT_INC(COMPARE_OP, hit);
            assert(_PyLong_DigitCount((PyLongObject *)left) <= 1 &&
                   _PyLong_DigitCount((PyLongObject *)right) <= 1);
            Py_ssize_t ileft = _PyLong_CompactValue((PyLongObject *)left);
            Py_ssize_t iright = _PyLong_CompactValue((PyLongObject *)right);
            // 2 if <, 4 if >, 8 if ==; this matches the low 4 bits of the oparg
            int sign_ish = COMPARISON_BIT(ileft, iright);
            _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
            _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
            res = (sign_ish & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            #line 3021 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(COMPARE_OP_STR) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *res;
            #line 2148 "Python/bytecodes.c"
            DEOPT_IF(!PyUnicode_CheckExact(left), COMPARE_OP);
            DEOPT_IF(!PyUnicode_CheckExact(right), COMPARE_OP);
            STAT_INC(COMPARE_OP, hit);
            int eq = _PyUnicode_Equal(left, right);
            assert((oparg >> 5) == Py_EQ || (oparg >> 5) == Py_NE);
            _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);
            _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
            assert(eq == 0 || eq == 1);
            assert((oparg & 0xf) == COMPARISON_NOT_EQUALS || (oparg & 0xf) == COMPARISON_EQUALS);
            assert(COMPARISON_NOT_EQUALS + 1 == COMPARISON_EQUALS);
            res = ((COMPARISON_NOT_EQUALS + eq) & oparg) ? Py_True : Py_False;
            // It's always a bool, so we don't care about oparg & 16.
            #line 3045 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(IS_OP) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *b;
            #line 2163 "Python/bytecodes.c"
            int res = Py_Is(left, right) ^ oparg;
            #line 3058 "Python/generated_cases.c.h"
            Py_DECREF(left);
            Py_DECREF(right);
            #line 2165 "Python/bytecodes.c"
            b = res ? Py_True : Py_False;
            #line 3063 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = b;
            DISPATCH();
        }

        TARGET(CONTAINS_OP) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *b;
            #line 2169 "Python/bytecodes.c"
            int res = PySequence_Contains(right, left);
            #line 3075 "Python/generated_cases.c.h"
            Py_DECREF(left);
            Py_DECREF(right);
            #line 2171 "Python/bytecodes.c"
            if (res < 0) goto pop_2_error;
            b = (res ^ oparg) ? Py_True : Py_False;
            #line 3081 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = b;
            DISPATCH();
        }

        TARGET(CHECK_EG_MATCH) {
            PyObject *match_type = stack_pointer[-1];
            PyObject *exc_value = stack_pointer[-2];
            PyObject *rest;
            PyObject *match;
            #line 2176 "Python/bytecodes.c"
            if (check_except_star_type_valid(tstate, match_type) < 0) {
            #line 3094 "Python/generated_cases.c.h"
                Py_DECREF(exc_value);
                Py_DECREF(match_type);
            #line 2178 "Python/bytecodes.c"
                if (true) goto pop_2_error;
            }

            match = NULL;
            rest = NULL;
            int res = exception_group_match(exc_value, match_type,
                                            &match, &rest);
            #line 3105 "Python/generated_cases.c.h"
            Py_DECREF(exc_value);
            Py_DECREF(match_type);
            #line 2186 "Python/bytecodes.c"
            if (res < 0) goto pop_2_error;

            assert((match == NULL) == (rest == NULL));
            if (match == NULL) goto pop_2_error;

            if (!Py_IsNone(match)) {
                PyErr_SetHandledException(match);
            }
            #line 3117 "Python/generated_cases.c.h"
            stack_pointer[-1] = match;
            stack_pointer[-2] = rest;
            DISPATCH();
        }

        TARGET(CHECK_EXC_MATCH) {
            PyObject *right = stack_pointer[-1];
            PyObject *left = stack_pointer[-2];
            PyObject *b;
            #line 2197 "Python/bytecodes.c"
            assert(PyExceptionInstance_Check(left));
            if (check_except_type_valid(tstate, right) < 0) {
            #line 3130 "Python/generated_cases.c.h"
                 Py_DECREF(right);
            #line 2200 "Python/bytecodes.c"
                 if (true) goto pop_1_error;
            }

            int res = PyErr_GivenExceptionMatches(left, right);
            #line 3137 "Python/generated_cases.c.h"
            Py_DECREF(right);
            #line 2205 "Python/bytecodes.c"
            b = res ? Py_True : Py_False;
            #line 3141 "Python/generated_cases.c.h"
            stack_pointer[-1] = b;
            DISPATCH();
        }

        TARGET(IMPORT_NAME) {
            PyObject *fromlist = stack_pointer[-1];
            PyObject *level = stack_pointer[-2];
            PyObject *res;
            #line 2209 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            res = import_name(tstate, frame, name, fromlist, level);
            #line 3153 "Python/generated_cases.c.h"
            Py_DECREF(level);
            Py_DECREF(fromlist);
            #line 2212 "Python/bytecodes.c"
            if (res == NULL) goto pop_2_error;
            #line 3158 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(IMPORT_FROM) {
            PyObject *from = stack_pointer[-1];
            PyObject *res;
            #line 2216 "Python/bytecodes.c"
            PyObject *name = GETITEM(FRAME_CO_NAMES, oparg);
            res = import_from(tstate, from, name);
            if (res == NULL) goto error;
            #line 3171 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(JUMP_FORWARD) {
            #line 2222 "Python/bytecodes.c"
            JUMPBY(oparg);
            #line 3180 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(JUMP_BACKWARD) {
            #line 2226 "Python/bytecodes.c"
            _Py_CODEUNIT *here = next_instr - 1;
            assert(oparg <= INSTR_OFFSET());
            JUMPBY(1-oparg);
            #if ENABLE_SPECIALIZATION
            here[1].cache += (1 << OPTIMIZER_BITS_IN_COUNTER);
            if (here[1].cache > tstate->interp->optimizer_backedge_threshold) {
                OBJECT_STAT_INC(optimization_attempts);
                frame = _PyOptimizer_BackEdge(frame, here, next_instr, stack_pointer);
                if (frame == NULL) {
                    frame = cframe.current_frame;
                    goto error;
                }
                assert(frame == cframe.current_frame);
                here[1].cache &= ((1 << OPTIMIZER_BITS_IN_COUNTER) -1);
                goto resume_frame;
            }
            #endif  /* ENABLE_SPECIALIZATION */
            #line 3203 "Python/generated_cases.c.h"
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(ENTER_EXECUTOR) {
            #line 2257 "Python/bytecodes.c"
            PyCodeObject *code = _PyFrame_GetCode(frame);
            _PyExecutorObject *executor = (_PyExecutorObject *)code->co_executors->executors[oparg&255];
            Py_INCREF(executor);
            frame = executor->execute(executor, frame, stack_pointer);
            if (frame == NULL) {
                frame = cframe.current_frame;
                goto resume_with_error;
            }
            goto resume_frame;
            #line 3219 "Python/generated_cases.c.h"
        }

        TARGET(POP_JUMP_IF_FALSE) {
            PyObject *cond = stack_pointer[-1];
            #line 2269 "Python/bytecodes.c"
            assert(PyBool_Check(cond));
            JUMPBY(oparg * Py_IsFalse(cond));
            #line 3227 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(POP_JUMP_IF_TRUE) {
            PyObject *cond = stack_pointer[-1];
            #line 2274 "Python/bytecodes.c"
            assert(PyBool_Check(cond));
            JUMPBY(oparg * Py_IsTrue(cond));
            #line 3237 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(POP_JUMP_IF_NOT_NONE) {
            PyObject *value = stack_pointer[-1];
            #line 2279 "Python/bytecodes.c"
            if (!Py_IsNone(value)) {
            #line 3246 "Python/generated_cases.c.h"
                Py_DECREF(value);
            #line 2281 "Python/bytecodes.c"
                JUMPBY(oparg);
            }
            #line 3251 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(POP_JUMP_IF_NONE) {
            PyObject *value = stack_pointer[-1];
            #line 2286 "Python/bytecodes.c"
            if (Py_IsNone(value)) {
                JUMPBY(oparg);
            }
            else {
            #line 3263 "Python/generated_cases.c.h"
                Py_DECREF(value);
            #line 2291 "Python/bytecodes.c"
            }
            #line 3267 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(JUMP_BACKWARD_NO_INTERRUPT) {
            #line 2295 "Python/bytecodes.c"
            /* This bytecode is used in the `yield from` or `await` loop.
             * If there is an interrupt, we want it handled in the innermost
             * generator or coroutine, so we deliberately do not check it here.
             * (see bpo-30039).
             */
            JUMPBY(-oparg);
            #line 3280 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(GET_LEN) {
            PyObject *obj = stack_pointer[-1];
            PyObject *len_o;
            #line 2304 "Python/bytecodes.c"
            // PUSH(len(TOS))
            Py_ssize_t len_i = PyObject_Length(obj);
            if (len_i < 0) goto error;
            len_o = PyLong_FromSsize_t(len_i);
            if (len_o == NULL) goto error;
            #line 3293 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = len_o;
            DISPATCH();
        }

        TARGET(MATCH_CLASS) {
            PyObject *names = stack_pointer[-1];
            PyObject *type = stack_pointer[-2];
            PyObject *subject = stack_pointer[-3];
            PyObject *attrs;
            #line 2312 "Python/bytecodes.c"
            // Pop TOS and TOS1. Set TOS to a tuple of attributes on success, or
            // None on failure.
            assert(PyTuple_CheckExact(names));
            attrs = match_class(tstate, subject, type, oparg, names);
            #line 3309 "Python/generated_cases.c.h"
            Py_DECREF(subject);
            Py_DECREF(type);
            Py_DECREF(names);
            #line 2317 "Python/bytecodes.c"
            if (attrs) {
                assert(PyTuple_CheckExact(attrs));  // Success!
            }
            else {
                if (_PyErr_Occurred(tstate)) goto pop_3_error;
                attrs = Py_None;  // Failure!
            }
            #line 3321 "Python/generated_cases.c.h"
            STACK_SHRINK(2);
            stack_pointer[-1] = attrs;
            DISPATCH();
        }

        TARGET(MATCH_MAPPING) {
            PyObject *subject = stack_pointer[-1];
            PyObject *res;
            #line 2327 "Python/bytecodes.c"
            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_MAPPING;
            res = match ? Py_True : Py_False;
            #line 3333 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(MATCH_SEQUENCE) {
            PyObject *subject = stack_pointer[-1];
            PyObject *res;
            #line 2332 "Python/bytecodes.c"
            int match = Py_TYPE(subject)->tp_flags & Py_TPFLAGS_SEQUENCE;
            res = match ? Py_True : Py_False;
            #line 3345 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(MATCH_KEYS) {
            PyObject *keys = stack_pointer[-1];
            PyObject *subject = stack_pointer[-2];
            PyObject *values_or_none;
            #line 2337 "Python/bytecodes.c"
            // On successful match, PUSH(values). Otherwise, PUSH(None).
            values_or_none = match_keys(tstate, subject, keys);
            if (values_or_none == NULL) goto error;
            #line 3359 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = values_or_none;
            DISPATCH();
        }

        TARGET(GET_ITER) {
            PyObject *iterable = stack_pointer[-1];
            PyObject *iter;
            #line 2343 "Python/bytecodes.c"
            /* before: [obj]; after [getiter(obj)] */
            iter = PyObject_GetIter(iterable);
            #line 3371 "Python/generated_cases.c.h"
            Py_DECREF(iterable);
            #line 2346 "Python/bytecodes.c"
            if (iter == NULL) goto pop_1_error;
            #line 3375 "Python/generated_cases.c.h"
            stack_pointer[-1] = iter;
            DISPATCH();
        }

        TARGET(GET_YIELD_FROM_ITER) {
            PyObject *iterable = stack_pointer[-1];
            PyObject *iter;
            #line 2350 "Python/bytecodes.c"
            /* before: [obj]; after [getiter(obj)] */
            if (PyCoro_CheckExact(iterable)) {
                /* `iterable` is a coroutine */
                if (!(_PyFrame_GetCode(frame)->co_flags & (CO_COROUTINE | CO_ITERABLE_COROUTINE))) {
                    /* and it is used in a 'yield from' expression of a
                       regular generator. */
                    _PyErr_SetString(tstate, PyExc_TypeError,
                                     "cannot 'yield from' a coroutine object "
                                     "in a non-coroutine generator");
                    goto error;
                }
                iter = iterable;
            }
            else if (PyGen_CheckExact(iterable)) {
                iter = iterable;
            }
            else {
                /* `iterable` is not a generator. */
                iter = PyObject_GetIter(iterable);
                if (iter == NULL) {
                    goto error;
                }
            #line 3406 "Python/generated_cases.c.h"
                Py_DECREF(iterable);
            #line 2373 "Python/bytecodes.c"
            }
            #line 3410 "Python/generated_cases.c.h"
            stack_pointer[-1] = iter;
            DISPATCH();
        }

        TARGET(FOR_ITER) {
            PREDICTED(FOR_ITER);
            static_assert(INLINE_CACHE_ENTRIES_FOR_ITER == 1, "incorrect cache size");
            PyObject *iter = stack_pointer[-1];
            PyObject *next;
            #line 2391 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyForIterCache *cache = (_PyForIterCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_ForIter(iter, next_instr, oparg);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(FOR_ITER, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            /* before: [iter]; after: [iter, iter()] *or* [] (and jump over END_FOR.) */
            next = (*Py_TYPE(iter)->tp_iternext)(iter);
            if (next == NULL) {
                if (_PyErr_Occurred(tstate)) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {
                        goto error;
                    }
                    monitor_raise(tstate, frame, next_instr-1);
                    _PyErr_Clear(tstate);
                }
                /* iterator ended normally */
                assert(next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == END_FOR ||
                       next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == INSTRUMENTED_END_FOR);
                Py_DECREF(iter);
                STACK_SHRINK(1);
                SKIP_OVER(INLINE_CACHE_ENTRIES_FOR_ITER);
                /* Jump forward oparg, then skip following END_FOR instruction */
                JUMPBY(oparg + 1);
                DISPATCH();
            }
            // Common case: no jump, leave it to the code generator
            #line 3452 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = next;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(INSTRUMENTED_FOR_ITER) {
            #line 2425 "Python/bytecodes.c"
            _Py_CODEUNIT *here = next_instr-1;
            _Py_CODEUNIT *target;
            PyObject *iter = TOP();
            PyObject *next = (*Py_TYPE(iter)->tp_iternext)(iter);
            if (next != NULL) {
                PUSH(next);
                target = next_instr + INLINE_CACHE_ENTRIES_FOR_ITER;
            }
            else {
                if (_PyErr_Occurred(tstate)) {
                    if (!_PyErr_ExceptionMatches(tstate, PyExc_StopIteration)) {
                        goto error;
                    }
                    monitor_raise(tstate, frame, here);
                    _PyErr_Clear(tstate);
                }
                /* iterator ended normally */
                assert(next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == END_FOR ||
                       next_instr[INLINE_CACHE_ENTRIES_FOR_ITER + oparg].op.code == INSTRUMENTED_END_FOR);
                STACK_SHRINK(1);
                Py_DECREF(iter);
                /* Skip END_FOR */
                target = next_instr + INLINE_CACHE_ENTRIES_FOR_ITER + oparg + 1;
            }
            INSTRUMENTED_JUMP(here, target, PY_MONITORING_EVENT_BRANCH);
            #line 3486 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(FOR_ITER_LIST) {
            PyObject *iter = stack_pointer[-1];
            PyObject *next;
            #line 2453 "Python/bytecodes.c"
            DEOPT_IF(Py_TYPE(iter) != &PyListIter_Type, FOR_ITER);
            _PyListIterObject *it = (_PyListIterObject *)iter;
            STAT_INC(FOR_ITER, hit);
            PyListObject *seq = it->it_seq;
            if (seq) {
                if (it->it_index < PyList_GET_SIZE(seq)) {
                    next = Py_NewRef(PyList_GET_ITEM(seq, it->it_index++));
                    goto end_for_iter_list;  // End of this instruction
                }
                it->it_seq = NULL;
                Py_DECREF(seq);
            }
            Py_DECREF(iter);
            STACK_SHRINK(1);
            SKIP_OVER(INLINE_CACHE_ENTRIES_FOR_ITER);
            /* Jump forward oparg, then skip following END_FOR instruction */
            JUMPBY(oparg + 1);
            DISPATCH();
        end_for_iter_list:
            // Common case: no jump, leave it to the code generator
            #line 3514 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = next;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(FOR_ITER_TUPLE) {
            PyObject *iter = stack_pointer[-1];
            PyObject *next;
            #line 2476 "Python/bytecodes.c"
            _PyTupleIterObject *it = (_PyTupleIterObject *)iter;
            DEOPT_IF(Py_TYPE(it) != &PyTupleIter_Type, FOR_ITER);
            STAT_INC(FOR_ITER, hit);
            PyTupleObject *seq = it->it_seq;
            if (seq) {
                if (it->it_index < PyTuple_GET_SIZE(seq)) {
                    next = Py_NewRef(PyTuple_GET_ITEM(seq, it->it_index++));
                    goto end_for_iter_tuple;  // End of this instruction
                }
                it->it_seq = NULL;
                Py_DECREF(seq);
            }
            Py_DECREF(iter);
            STACK_SHRINK(1);
            SKIP_OVER(INLINE_CACHE_ENTRIES_FOR_ITER);
            /* Jump forward oparg, then skip following END_FOR instruction */
            JUMPBY(oparg + 1);
            DISPATCH();
        end_for_iter_tuple:
            // Common case: no jump, leave it to the code generator
            #line 3545 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = next;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(FOR_ITER_RANGE) {
            PyObject *iter = stack_pointer[-1];
            PyObject *next;
            #line 2499 "Python/bytecodes.c"
            _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
            DEOPT_IF(Py_TYPE(r) != &PyRangeIter_Type, FOR_ITER);
            STAT_INC(FOR_ITER, hit);
            if (r->len <= 0) {
                STACK_SHRINK(1);
                Py_DECREF(r);
                SKIP_OVER(INLINE_CACHE_ENTRIES_FOR_ITER);
                // Jump over END_FOR instruction.
                JUMPBY(oparg + 1);
                DISPATCH();
            }
            long value = r->start;
            r->start = value + r->step;
            r->len--;
            next = PyLong_FromLong(value);
            if (next == NULL) {
                goto error;
            }
            #line 3574 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = next;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(FOR_ITER_GEN) {
            PyObject *iter = stack_pointer[-1];
            #line 2520 "Python/bytecodes.c"
            DEOPT_IF(tstate->interp->eval_frame, FOR_ITER);
            PyGenObject *gen = (PyGenObject *)iter;
            DEOPT_IF(Py_TYPE(gen) != &PyGen_Type, FOR_ITER);
            DEOPT_IF(gen->gi_frame_state >= FRAME_EXECUTING, FOR_ITER);
            STAT_INC(FOR_ITER, hit);
            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;
            frame->return_offset = oparg;
            _PyFrame_StackPush(gen_frame, Py_None);
            gen->gi_frame_state = FRAME_EXECUTING;
            gen->gi_exc_state.previous_item = tstate->exc_info;
            tstate->exc_info = &gen->gi_exc_state;
            SKIP_OVER(INLINE_CACHE_ENTRIES_FOR_ITER);
            assert(next_instr[oparg].op.code == END_FOR ||
                   next_instr[oparg].op.code == INSTRUMENTED_END_FOR);
            DISPATCH_INLINED(gen_frame);
            #line 3599 "Python/generated_cases.c.h"
        }

        TARGET(BEFORE_ASYNC_WITH) {
            PyObject *mgr = stack_pointer[-1];
            PyObject *exit;
            PyObject *res;
            #line 2538 "Python/bytecodes.c"
            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__aenter__));
            if (enter == NULL) {
                if (!_PyErr_Occurred(tstate)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object does not support the "
                                  "asynchronous context manager protocol",
                                  Py_TYPE(mgr)->tp_name);
                }
                goto error;
            }
            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__aexit__));
            if (exit == NULL) {
                if (!_PyErr_Occurred(tstate)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object does not support the "
                                  "asynchronous context manager protocol "
                                  "(missed __aexit__ method)",
                                  Py_TYPE(mgr)->tp_name);
                }
                Py_DECREF(enter);
                goto error;
            }
            #line 3629 "Python/generated_cases.c.h"
            Py_DECREF(mgr);
            #line 2561 "Python/bytecodes.c"
            res = _PyObject_CallNoArgs(enter);
            Py_DECREF(enter);
            if (res == NULL) {
                Py_DECREF(exit);
                if (true) goto pop_1_error;
            }
            #line 3638 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            stack_pointer[-2] = exit;
            DISPATCH();
        }

        TARGET(BEFORE_WITH) {
            PyObject *mgr = stack_pointer[-1];
            PyObject *exit;
            PyObject *res;
            #line 2570 "Python/bytecodes.c"
            /* pop the context manager, push its __exit__ and the
             * value returned from calling its __enter__
             */
            PyObject *enter = _PyObject_LookupSpecial(mgr, &_Py_ID(__enter__));
            if (enter == NULL) {
                if (!_PyErr_Occurred(tstate)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object does not support the "
                                  "context manager protocol",
                                  Py_TYPE(mgr)->tp_name);
                }
                goto error;
            }
            exit = _PyObject_LookupSpecial(mgr, &_Py_ID(__exit__));
            if (exit == NULL) {
                if (!_PyErr_Occurred(tstate)) {
                    _PyErr_Format(tstate, PyExc_TypeError,
                                  "'%.200s' object does not support the "
                                  "context manager protocol "
                                  "(missed __exit__ method)",
                                  Py_TYPE(mgr)->tp_name);
                }
                Py_DECREF(enter);
                goto error;
            }
            #line 3675 "Python/generated_cases.c.h"
            Py_DECREF(mgr);
            #line 2596 "Python/bytecodes.c"
            res = _PyObject_CallNoArgs(enter);
            Py_DECREF(enter);
            if (res == NULL) {
                Py_DECREF(exit);
                if (true) goto pop_1_error;
            }
            #line 3684 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            stack_pointer[-2] = exit;
            DISPATCH();
        }

        TARGET(WITH_EXCEPT_START) {
            PyObject *val = stack_pointer[-1];
            PyObject *lasti = stack_pointer[-3];
            PyObject *exit_func = stack_pointer[-4];
            PyObject *res;
            #line 2605 "Python/bytecodes.c"
            /* At the top of the stack are 4 values:
               - val: TOP = exc_info()
               - unused: SECOND = previous exception
               - lasti: THIRD = lasti of exception in exc_info()
               - exit_func: FOURTH = the context.__exit__ bound method
               We call FOURTH(type(TOP), TOP, GetTraceback(TOP)).
               Then we push the __exit__ return value.
            */
            PyObject *exc, *tb;

            assert(val && PyExceptionInstance_Check(val));
            exc = PyExceptionInstance_Class(val);
            tb = PyException_GetTraceback(val);
            Py_XDECREF(tb);
            assert(PyLong_Check(lasti));
            (void)lasti; // Shut up compiler warning if asserts are off
            PyObject *stack[4] = {NULL, exc, val, tb};
            res = PyObject_Vectorcall(exit_func, stack + 1,
                    3 | PY_VECTORCALL_ARGUMENTS_OFFSET, NULL);
            if (res == NULL) goto error;
            #line 3717 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(PUSH_EXC_INFO) {
            PyObject *new_exc = stack_pointer[-1];
            PyObject *prev_exc;
            #line 2644 "Python/bytecodes.c"
            _PyErr_StackItem *exc_info = tstate->exc_info;
            if (exc_info->exc_value != NULL) {
                prev_exc = exc_info->exc_value;
            }
            else {
                prev_exc = Py_None;
            }
            assert(PyExceptionInstance_Check(new_exc));
            exc_info->exc_value = Py_NewRef(new_exc);
            #line 3736 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = new_exc;
            stack_pointer[-2] = prev_exc;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_METHOD_WITH_VALUES) {
            PyObject *self = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            uint32_t keys_version = read_u32(&next_instr[3].cache);
            PyObject *descr = read_obj(&next_instr[5].cache);
            #line 2656 "Python/bytecodes.c"
            /* Cached method object */
            PyTypeObject *self_cls = Py_TYPE(self);
            assert(type_version != 0);
            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);
            assert(self_cls->tp_flags & Py_TPFLAGS_MANAGED_DICT);
            PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(self);
            DEOPT_IF(!_PyDictOrValues_IsValues(dorv), LOAD_ATTR);
            PyHeapTypeObject *self_heap_type = (PyHeapTypeObject *)self_cls;
            DEOPT_IF(self_heap_type->ht_cached_keys->dk_version !=
                     keys_version, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            res2 = Py_NewRef(descr);
            assert(_PyType_HasFeature(Py_TYPE(res2), Py_TPFLAGS_METHOD_DESCRIPTOR));
            res = self;
            assert(oparg & 1);
            #line 3767 "Python/generated_cases.c.h"
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_METHOD_NO_DICT) {
            PyObject *self = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            PyObject *descr = read_obj(&next_instr[5].cache);
            #line 2675 "Python/bytecodes.c"
            PyTypeObject *self_cls = Py_TYPE(self);
            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);
            assert(self_cls->tp_dictoffset == 0);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            res2 = Py_NewRef(descr);
            res = self;
            assert(oparg & 1);
            #line 3791 "Python/generated_cases.c.h"
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(LOAD_ATTR_METHOD_LAZY_DICT) {
            PyObject *self = stack_pointer[-1];
            PyObject *res2 = NULL;
            PyObject *res;
            uint32_t type_version = read_u32(&next_instr[1].cache);
            PyObject *descr = read_obj(&next_instr[5].cache);
            #line 2687 "Python/bytecodes.c"
            PyTypeObject *self_cls = Py_TYPE(self);
            DEOPT_IF(self_cls->tp_version_tag != type_version, LOAD_ATTR);
            Py_ssize_t dictoffset = self_cls->tp_dictoffset;
            assert(dictoffset > 0);
            PyObject *dict = *(PyObject **)((char *)self + dictoffset);
            /* This object has a __dict__, just not yet created */
            DEOPT_IF(dict != NULL, LOAD_ATTR);
            STAT_INC(LOAD_ATTR, hit);
            assert(descr != NULL);
            assert(_PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_METHOD_DESCRIPTOR));
            res2 = Py_NewRef(descr);
            res = self;
            assert(oparg & 1);
            #line 3819 "Python/generated_cases.c.h"
            STACK_GROW(((oparg & 1) ? 1 : 0));
            stack_pointer[-1] = res;
            if (oparg & 1) { stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))] = res2; }
            next_instr += 9;
            DISPATCH();
        }

        TARGET(KW_NAMES) {
            #line 2703 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg < PyTuple_GET_SIZE(FRAME_CO_CONSTS));
            kwnames = GETITEM(FRAME_CO_CONSTS, oparg);
            #line 3832 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_CALL) {
            #line 2709 "Python/bytecodes.c"
            int is_meth = PEEK(oparg+2) != NULL;
            int total_args = oparg + is_meth;
            PyObject *function = PEEK(total_args + 1);
            PyObject *arg = total_args == 0 ?
                &_PyInstrumentation_MISSING : PEEK(total_args);
            int err = _Py_call_instrumentation_2args(
                    tstate, PY_MONITORING_EVENT_CALL,
                    frame, next_instr-1, function, arg);
            if (err) goto error;
            _PyCallCache *cache = (_PyCallCache *)next_instr;
            INCREMENT_ADAPTIVE_COUNTER(cache->counter);
            GO_TO_INSTRUCTION(CALL);
            #line 3850 "Python/generated_cases.c.h"
        }

        TARGET(CALL) {
            PREDICTED(CALL);
            static_assert(INLINE_CACHE_ENTRIES_CALL == 3, "incorrect cache size");
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 2755 "Python/bytecodes.c"
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            #if ENABLE_SPECIALIZATION
            _PyCallCache *cache = (_PyCallCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_Call(callable, next_instr, total_args, kwnames);
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(CALL, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            if (!is_meth && Py_TYPE(callable) == &PyMethod_Type) {
                is_meth = 1;  // For consistenct; it's dead, though
                args--;
                total_args++;
                PyObject *self = ((PyMethodObject *)callable)->im_self;
                args[0] = Py_NewRef(self);
                method = ((PyMethodObject *)callable)->im_func;
                args[-1] = Py_NewRef(method);
                Py_DECREF(callable);
                callable = method;
            }
            int positional_args = total_args - KWNAMES_LEN();
            // Check if the call can be inlined or not
            if (Py_TYPE(callable) == &PyFunction_Type &&
                tstate->interp->eval_frame == NULL &&
                ((PyFunctionObject *)callable)->vectorcall == _PyFunction_Vectorcall)
            {
                int code_flags = ((PyCodeObject*)PyFunction_GET_CODE(callable))->co_flags;
                PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(callable));
                _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit(
                    tstate, (PyFunctionObject *)callable, locals,
                    args, positional_args, kwnames
                );
                kwnames = NULL;
                // Manipulate stack directly since we leave using DISPATCH_INLINED().
                STACK_SHRINK(oparg + 2);
                // The frame has stolen all the arguments from the stack,
                // so there is no need to clean them up.
                if (new_frame == NULL) {
                    goto error;
                }
                SKIP_OVER(INLINE_CACHE_ENTRIES_CALL);
                frame->return_offset = 0;
                DISPATCH_INLINED(new_frame);
            }
            /* Callable is not a normal Python function */
            res = PyObject_Vectorcall(
                callable, args,
                positional_args | PY_VECTORCALL_ARGUMENTS_OFFSET,
                kwnames);
            if (opcode == INSTRUMENTED_CALL) {
                PyObject *arg = total_args == 0 ?
                    &_PyInstrumentation_MISSING : PEEK(total_args);
                if (res == NULL) {
                    _Py_call_instrumentation_exc2(
                        tstate, PY_MONITORING_EVENT_C_RAISE,
                        frame, next_instr-1, callable, arg);
                }
                else {
                    int err = _Py_call_instrumentation_2args(
                        tstate, PY_MONITORING_EVENT_C_RETURN,
                        frame, next_instr-1, callable, arg);
                    if (err < 0) {
                        Py_CLEAR(res);
                    }
                }
            }
            kwnames = NULL;
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF(callable);
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 3942 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_BOUND_METHOD_EXACT_ARGS) {
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            #line 2843 "Python/bytecodes.c"
            DEOPT_IF(method != NULL, CALL);
            DEOPT_IF(Py_TYPE(callable) != &PyMethod_Type, CALL);
            STAT_INC(CALL, hit);
            PyObject *self = ((PyMethodObject *)callable)->im_self;
            PEEK(oparg + 1) = Py_NewRef(self);  // callable
            PyObject *meth = ((PyMethodObject *)callable)->im_func;
            PEEK(oparg + 2) = Py_NewRef(meth);  // method
            Py_DECREF(callable);
            GO_TO_INSTRUCTION(CALL_PY_EXACT_ARGS);
            #line 3964 "Python/generated_cases.c.h"
        }

        TARGET(CALL_PY_EXACT_ARGS) {
            PREDICTED(CALL_PY_EXACT_ARGS);
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            uint32_t func_version = read_u32(&next_instr[1].cache);
            #line 2855 "Python/bytecodes.c"
            assert(kwnames == NULL);
            DEOPT_IF(tstate->interp->eval_frame, CALL);
            int is_meth = method != NULL;
            int argcount = oparg;
            if (is_meth) {
                callable = method;
                args--;
                argcount++;
            }
            DEOPT_IF(!PyFunction_Check(callable), CALL);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            DEOPT_IF(func->func_version != func_version, CALL);
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            DEOPT_IF(code->co_argcount != argcount, CALL);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, func, argcount);
            for (int i = 0; i < argcount; i++) {
                new_frame->localsplus[i] = args[i];
            }
            // Manipulate stack directly since we leave using DISPATCH_INLINED().
            STACK_SHRINK(oparg + 2);
            SKIP_OVER(INLINE_CACHE_ENTRIES_CALL);
            frame->return_offset = 0;
            DISPATCH_INLINED(new_frame);
            #line 3999 "Python/generated_cases.c.h"
        }

        TARGET(CALL_PY_WITH_DEFAULTS) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            uint32_t func_version = read_u32(&next_instr[1].cache);
            #line 2883 "Python/bytecodes.c"
            assert(kwnames == NULL);
            DEOPT_IF(tstate->interp->eval_frame, CALL);
            int is_meth = method != NULL;
            int argcount = oparg;
            if (is_meth) {
                callable = method;
                args--;
                argcount++;
            }
            DEOPT_IF(!PyFunction_Check(callable), CALL);
            PyFunctionObject *func = (PyFunctionObject *)callable;
            DEOPT_IF(func->func_version != func_version, CALL);
            PyCodeObject *code = (PyCodeObject *)func->func_code;
            assert(func->func_defaults);
            assert(PyTuple_CheckExact(func->func_defaults));
            int defcount = (int)PyTuple_GET_SIZE(func->func_defaults);
            assert(defcount <= code->co_argcount);
            int min_args = code->co_argcount - defcount;
            DEOPT_IF(argcount > code->co_argcount, CALL);
            DEOPT_IF(argcount < min_args, CALL);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize), CALL);
            STAT_INC(CALL, hit);
            _PyInterpreterFrame *new_frame = _PyFrame_PushUnchecked(tstate, func, code->co_argcount);
            for (int i = 0; i < argcount; i++) {
                new_frame->localsplus[i] = args[i];
            }
            for (int i = argcount; i < code->co_argcount; i++) {
                PyObject *def = PyTuple_GET_ITEM(func->func_defaults, i - min_args);
                new_frame->localsplus[i] = Py_NewRef(def);
            }
            // Manipulate stack and cache directly since we leave using DISPATCH_INLINED().
            STACK_SHRINK(oparg + 2);
            SKIP_OVER(INLINE_CACHE_ENTRIES_CALL);
            frame->return_offset = 0;
            DISPATCH_INLINED(new_frame);
            #line 4043 "Python/generated_cases.c.h"
        }

        TARGET(CALL_NO_KW_TYPE_1) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *null = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 2921 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg == 1);
            DEOPT_IF(null != NULL, CALL);
            PyObject *obj = args[0];
            DEOPT_IF(callable != (PyObject *)&PyType_Type, CALL);
            STAT_INC(CALL, hit);
            res = Py_NewRef(Py_TYPE(obj));
            Py_DECREF(obj);
            Py_DECREF(&PyType_Type);  // I.e., callable
            #line 4061 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(CALL_NO_KW_STR_1) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *null = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 2933 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg == 1);
            DEOPT_IF(null != NULL, CALL);
            DEOPT_IF(callable != (PyObject *)&PyUnicode_Type, CALL);
            STAT_INC(CALL, hit);
            PyObject *arg = args[0];
            res = PyObject_Str(arg);
            Py_DECREF(arg);
            Py_DECREF(&PyUnicode_Type);  // I.e., callable
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4085 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_TUPLE_1) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *null = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 2947 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg == 1);
            DEOPT_IF(null != NULL, CALL);
            DEOPT_IF(callable != (PyObject *)&PyTuple_Type, CALL);
            STAT_INC(CALL, hit);
            PyObject *arg = args[0];
            res = PySequence_Tuple(arg);
            Py_DECREF(arg);
            Py_DECREF(&PyTuple_Type);  // I.e., tuple
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4110 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_ALLOC_AND_ENTER_INIT) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *null = stack_pointer[-(2 + oparg)];
            #line 2961 "Python/bytecodes.c"
            /* This instruction does the following:
             * 1. Creates the object (by calling ``object.__new__``)
             * 2. Pushes a shim frame to the frame stack (to cleanup after ``__init__``)
             * 3. Pushes the frame for ``__init__`` to the frame stack
             * */
            assert(kwnames == NULL);
            _PyCallCache *cache = (_PyCallCache *)next_instr;
            DEOPT_IF(null != NULL, CALL);
            DEOPT_IF(!PyType_Check(callable), CALL);
            PyTypeObject *tp = (PyTypeObject *)callable;
            DEOPT_IF(tp->tp_version_tag != read_u32(cache->func_version), CALL);
            PyHeapTypeObject *cls = (PyHeapTypeObject *)callable;
            PyFunctionObject *init = (PyFunctionObject *)cls->_spec_cache.init;
            PyCodeObject *code = (PyCodeObject *)init->func_code;
            DEOPT_IF(code->co_argcount != oparg+1, CALL);
            DEOPT_IF(!_PyThreadState_HasStackSpace(tstate, code->co_framesize + _Py_InitCleanup.co_framesize), CALL);
            STAT_INC(CALL, hit);
            PyObject *self = _PyType_NewManagedObject(tp);
            if (self == NULL) {
                goto error;
            }
            Py_DECREF(tp);
            if (_Py_EnterRecursivePy(tstate)) {
                goto exit_unwind;
            }
            _PyInterpreterFrame *shim = _PyFrame_PushTrampolineUnchecked(
                tstate, (PyCodeObject *)&_Py_InitCleanup, 1, 0);
            assert(_PyCode_CODE((PyCodeObject *)shim->f_executable)[1].op.code == EXIT_INIT_CHECK);
            /* Push self onto stack of shim */
            Py_INCREF(self);
            shim->localsplus[0] = self;
            Py_INCREF(init);
            _PyInterpreterFrame *init_frame = _PyFrame_PushUnchecked(tstate, init, oparg+1);
            /* Copy self followed by args to __init__ frame */
            init_frame->localsplus[0] = self;
            for (int i = 0; i < oparg; i++) {
                init_frame->localsplus[i+1] = args[i];
            }
            SKIP_OVER(INLINE_CACHE_ENTRIES_CALL);
            frame->prev_instr = next_instr - 1;
            frame->return_offset = 0;
            STACK_SHRINK(oparg+2);
            _PyFrame_SetStackPointer(frame, stack_pointer);
            /* Link frames */
            init_frame->previous = shim;
            shim->previous = frame;
            frame = cframe.current_frame = init_frame;
            CALL_STAT_INC(inlined_py_calls);
            goto start_frame;
            #line 4173 "Python/generated_cases.c.h"
        }

        TARGET(EXIT_INIT_CHECK) {
            PyObject *should_be_none = stack_pointer[-1];
            #line 3013 "Python/bytecodes.c"
            assert(STACK_LEVEL() == 2);
            if (should_be_none != Py_None) {
                PyErr_Format(PyExc_TypeError,
                    "__init__() should return None, not '%.200s'",
                    Py_TYPE(should_be_none)->tp_name);
                goto error;
            }
            #line 4186 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            DISPATCH();
        }

        TARGET(CALL_BUILTIN_CLASS) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3023 "Python/bytecodes.c"
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            int kwnames_len = KWNAMES_LEN();
            DEOPT_IF(!PyType_Check(callable), CALL);
            PyTypeObject *tp = (PyTypeObject *)callable;
            DEOPT_IF(tp->tp_vectorcall == NULL, CALL);
            STAT_INC(CALL, hit);
            res = tp->tp_vectorcall((PyObject *)tp, args,
                                    total_args - kwnames_len, kwnames);
            kwnames = NULL;
            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(tp);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4218 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_BUILTIN_O) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3048 "Python/bytecodes.c"
            /* Builtin METH_O functions */
            assert(kwnames == NULL);
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            DEOPT_IF(total_args != 1, CALL);
            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);
            DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_O, CALL);
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);
            // This is slower but CPython promises to check all non-vectorcall
            // function calls.
            if (_Py_EnterRecursiveCallTstate(tstate, " while calling a Python object")) {
                goto error;
            }
            PyObject *arg = args[0];
            res = _PyCFunction_TrampolineCall(cfunc, PyCFunction_GET_SELF(callable), arg);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));

            Py_DECREF(arg);
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4260 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_BUILTIN_FAST) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3079 "Python/bytecodes.c"
            /* Builtin METH_FASTCALL functions, without keywords */
            assert(kwnames == NULL);
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);
            DEOPT_IF(PyCFunction_GET_FLAGS(callable) != METH_FASTCALL, CALL);
            STAT_INC(CALL, hit);
            PyCFunction cfunc = PyCFunction_GET_FUNCTION(callable);
            /* res = func(self, args, nargs) */
            res = ((_PyCFunctionFast)(void(*)(void))cfunc)(
                PyCFunction_GET_SELF(callable),
                args,
                total_args);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));

            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
                /* Not deopting because this doesn't mean our optimization was
                   wrong. `res` can be NULL for valid reasons. Eg. getattr(x,
                   'invalid'). In those cases an exception is set, so we must
                   handle it.
                */
            #line 4306 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_BUILTIN_FAST_WITH_KEYWORDS) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3114 "Python/bytecodes.c"
            /* Builtin METH_FASTCALL | METH_KEYWORDS functions */
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            DEOPT_IF(!PyCFunction_CheckExact(callable), CALL);
            DEOPT_IF(PyCFunction_GET_FLAGS(callable) !=
                (METH_FASTCALL | METH_KEYWORDS), CALL);
            STAT_INC(CALL, hit);
            /* res = func(self, args, nargs, kwnames) */
            _PyCFunctionFastWithKeywords cfunc =
                (_PyCFunctionFastWithKeywords)(void(*)(void))
                PyCFunction_GET_FUNCTION(callable);
            res = cfunc(
                PyCFunction_GET_SELF(callable),
                args,
                total_args - KWNAMES_LEN(),
                kwnames
            );
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            kwnames = NULL;

            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4352 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_LEN) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3149 "Python/bytecodes.c"
            assert(kwnames == NULL);
            /* len(o) */
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            DEOPT_IF(total_args != 1, CALL);
            PyInterpreterState *interp = _PyInterpreterState_GET();
            DEOPT_IF(callable != interp->callable_cache.len, CALL);
            STAT_INC(CALL, hit);
            PyObject *arg = args[0];
            Py_ssize_t len_i = PyObject_Length(arg);
            if (len_i < 0) {
                goto error;
            }
            res = PyLong_FromSsize_t(len_i);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));

            Py_DECREF(callable);
            Py_DECREF(arg);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4391 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(CALL_NO_KW_ISINSTANCE) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *callable = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3176 "Python/bytecodes.c"
            assert(kwnames == NULL);
            /* isinstance(o, o2) */
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                callable = method;
                args--;
                total_args++;
            }
            DEOPT_IF(total_args != 2, CALL);
            PyInterpreterState *interp = _PyInterpreterState_GET();
            DEOPT_IF(callable != interp->callable_cache.isinstance, CALL);
            STAT_INC(CALL, hit);
            PyObject *cls = args[1];
            PyObject *inst = args[0];
            int retval = PyObject_IsInstance(inst, cls);
            if (retval < 0) {
                goto error;
            }
            res = PyBool_FromLong(retval);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));

            Py_DECREF(inst);
            Py_DECREF(cls);
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4431 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            DISPATCH();
        }

        TARGET(CALL_NO_KW_LIST_APPEND) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *self = stack_pointer[-(1 + oparg)];
            PyObject *method = stack_pointer[-(2 + oparg)];
            #line 3206 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg == 1);
            assert(method != NULL);
            PyInterpreterState *interp = _PyInterpreterState_GET();
            DEOPT_IF(method != interp->callable_cache.list_append, CALL);
            DEOPT_IF(!PyList_Check(self), CALL);
            STAT_INC(CALL, hit);
            if (_PyList_AppendTakeRef((PyListObject *)self, args[0]) < 0) {
                goto pop_1_error;  // Since arg is DECREF'ed already
            }
            Py_DECREF(self);
            Py_DECREF(method);
            STACK_SHRINK(3);
            // CALL + POP_TOP
            SKIP_OVER(INLINE_CACHE_ENTRIES_CALL + 1);
            assert(next_instr[-1].op.code == POP_TOP);
            DISPATCH();
            #line 4461 "Python/generated_cases.c.h"
        }

        TARGET(CALL_NO_KW_METHOD_DESCRIPTOR_O) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3226 "Python/bytecodes.c"
            assert(kwnames == NULL);
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *callable =
                (PyMethodDescrObject *)PEEK(total_args + 1);
            DEOPT_IF(total_args != 2, CALL);
            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);
            PyMethodDef *meth = callable->d_method;
            DEOPT_IF(meth->ml_flags != METH_O, CALL);
            PyObject *arg = args[1];
            PyObject *self = args[0];
            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            // This is slower but CPython promises to check all non-vectorcall
            // function calls.
            if (_Py_EnterRecursiveCallTstate(tstate, " while calling a Python object")) {
                goto error;
            }
            res = _PyCFunction_TrampolineCall(cfunc, self, arg);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF(self);
            Py_DECREF(arg);
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4499 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3260 "Python/bytecodes.c"
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *callable =
                (PyMethodDescrObject *)PEEK(total_args + 1);
            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);
            PyMethodDef *meth = callable->d_method;
            DEOPT_IF(meth->ml_flags != (METH_FASTCALL|METH_KEYWORDS), CALL);
            PyTypeObject *d_type = callable->d_common.d_type;
            PyObject *self = args[0];
            DEOPT_IF(!Py_IS_TYPE(self, d_type), CALL);
            STAT_INC(CALL, hit);
            int nargs = total_args - 1;
            _PyCFunctionFastWithKeywords cfunc =
                (_PyCFunctionFastWithKeywords)(void(*)(void))meth->ml_meth;
            res = cfunc(self, args + 1, nargs - KWNAMES_LEN(), kwnames);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            kwnames = NULL;

            /* Free the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4541 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_METHOD_DESCRIPTOR_NOARGS) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3292 "Python/bytecodes.c"
            assert(kwnames == NULL);
            assert(oparg == 0 || oparg == 1);
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                args--;
                total_args++;
            }
            DEOPT_IF(total_args != 1, CALL);
            PyMethodDescrObject *callable = (PyMethodDescrObject *)SECOND();
            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);
            PyMethodDef *meth = callable->d_method;
            PyObject *self = args[0];
            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);
            DEOPT_IF(meth->ml_flags != METH_NOARGS, CALL);
            STAT_INC(CALL, hit);
            PyCFunction cfunc = meth->ml_meth;
            // This is slower but CPython promises to check all non-vectorcall
            // function calls.
            if (_Py_EnterRecursiveCallTstate(tstate, " while calling a Python object")) {
                goto error;
            }
            res = _PyCFunction_TrampolineCall(cfunc, self, NULL);
            _Py_LeaveRecursiveCallTstate(tstate);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            Py_DECREF(self);
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4583 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(CALL_NO_KW_METHOD_DESCRIPTOR_FAST) {
            PyObject **args = (stack_pointer - oparg);
            PyObject *method = stack_pointer[-(2 + oparg)];
            PyObject *res;
            #line 3324 "Python/bytecodes.c"
            assert(kwnames == NULL);
            int is_meth = method != NULL;
            int total_args = oparg;
            if (is_meth) {
                args--;
                total_args++;
            }
            PyMethodDescrObject *callable =
                (PyMethodDescrObject *)PEEK(total_args + 1);
            /* Builtin METH_FASTCALL methods, without keywords */
            DEOPT_IF(!Py_IS_TYPE(callable, &PyMethodDescr_Type), CALL);
            PyMethodDef *meth = callable->d_method;
            DEOPT_IF(meth->ml_flags != METH_FASTCALL, CALL);
            PyObject *self = args[0];
            DEOPT_IF(!Py_IS_TYPE(self, callable->d_common.d_type), CALL);
            STAT_INC(CALL, hit);
            _PyCFunctionFast cfunc =
                (_PyCFunctionFast)(void(*)(void))meth->ml_meth;
            int nargs = total_args - 1;
            res = cfunc(self, args + 1, nargs);
            assert((res != NULL) ^ (_PyErr_Occurred(tstate) != NULL));
            /* Clear the stack of the arguments. */
            for (int i = 0; i < total_args; i++) {
                Py_DECREF(args[i]);
            }
            Py_DECREF(callable);
            if (res == NULL) { STACK_SHRINK(oparg); goto pop_2_error; }
            #line 4624 "Python/generated_cases.c.h"
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 3;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(INSTRUMENTED_CALL_FUNCTION_EX) {
            #line 3355 "Python/bytecodes.c"
            GO_TO_INSTRUCTION(CALL_FUNCTION_EX);
            #line 4636 "Python/generated_cases.c.h"
        }

        TARGET(CALL_FUNCTION_EX) {
            PREDICTED(CALL_FUNCTION_EX);
            PyObject *kwargs = (oparg & 1) ? stack_pointer[-(((oparg & 1) ? 1 : 0))] : NULL;
            PyObject *callargs = stack_pointer[-(1 + ((oparg & 1) ? 1 : 0))];
            PyObject *func = stack_pointer[-(2 + ((oparg & 1) ? 1 : 0))];
            PyObject *result;
            #line 3359 "Python/bytecodes.c"
            // DICT_MERGE is called before this opcode if there are kwargs.
            // It converts all dict subtypes in kwargs into regular dicts.
            assert(kwargs == NULL || PyDict_CheckExact(kwargs));
            if (!PyTuple_CheckExact(callargs)) {
                if (check_args_iterable(tstate, func, callargs) < 0) {
                    goto error;
                }
                PyObject *tuple = PySequence_Tuple(callargs);
                if (tuple == NULL) {
                    goto error;
                }
                Py_SETREF(callargs, tuple);
            }
            assert(PyTuple_CheckExact(callargs));
            EVAL_CALL_STAT_INC_IF_FUNCTION(EVAL_CALL_FUNCTION_EX, func);
            if (opcode == INSTRUMENTED_CALL_FUNCTION_EX &&
                !PyFunction_Check(func) && !PyMethod_Check(func)
            ) {
                PyObject *arg = PyTuple_GET_SIZE(callargs) > 0 ?
                    PyTuple_GET_ITEM(callargs, 0) : Py_None;
                int err = _Py_call_instrumentation_2args(
                    tstate, PY_MONITORING_EVENT_CALL,
                    frame, next_instr-1, func, arg);
                if (err) goto error;
                result = PyObject_Call(func, callargs, kwargs);
                if (result == NULL) {
                    _Py_call_instrumentation_exc2(
                        tstate, PY_MONITORING_EVENT_C_RAISE,
                        frame, next_instr-1, func, arg);
                }
                else {
                    int err = _Py_call_instrumentation_2args(
                        tstate, PY_MONITORING_EVENT_C_RETURN,
                        frame, next_instr-1, func, arg);
                    if (err < 0) {
                        Py_CLEAR(result);
                    }
                }
            }
            else {
                if (Py_TYPE(func) == &PyFunction_Type &&
                    tstate->interp->eval_frame == NULL &&
                    ((PyFunctionObject *)func)->vectorcall == _PyFunction_Vectorcall) {
                    assert(PyTuple_CheckExact(callargs));
                    Py_ssize_t nargs = PyTuple_GET_SIZE(callargs);
                    int code_flags = ((PyCodeObject *)PyFunction_GET_CODE(func))->co_flags;
                    PyObject *locals = code_flags & CO_OPTIMIZED ? NULL : Py_NewRef(PyFunction_GET_GLOBALS(func));

                    _PyInterpreterFrame *new_frame = _PyEvalFramePushAndInit_Ex(tstate,
                                                                                (PyFunctionObject *)func, locals,
                                                                                nargs, callargs, kwargs);
                    // Need to manually shrink the stack since we exit with DISPATCH_INLINED.
                    STACK_SHRINK(oparg + 3);
                    if (new_frame == NULL) {
                        goto error;
                    }
                    frame->return_offset = 0;
                    DISPATCH_INLINED(new_frame);
                }
                result = PyObject_Call(func, callargs, kwargs);
            }
            #line 4707 "Python/generated_cases.c.h"
            Py_DECREF(func);
            Py_DECREF(callargs);
            Py_XDECREF(kwargs);
            #line 3421 "Python/bytecodes.c"
            assert(PEEK(3 + (oparg & 1)) == NULL);
            if (result == NULL) { STACK_SHRINK(((oparg & 1) ? 1 : 0)); goto pop_3_error; }
            #line 4714 "Python/generated_cases.c.h"
            STACK_SHRINK(((oparg & 1) ? 1 : 0));
            STACK_SHRINK(2);
            stack_pointer[-1] = result;
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(MAKE_FUNCTION) {
            PyObject *codeobj = stack_pointer[-1];
            PyObject *func;
            #line 3427 "Python/bytecodes.c"

            PyFunctionObject *func_obj = (PyFunctionObject *)
                PyFunction_New(codeobj, GLOBALS());

            Py_DECREF(codeobj);
            if (func_obj == NULL) {
                goto error;
            }

            func_obj->func_version = ((PyCodeObject *)codeobj)->co_version;
            func = (PyObject *)func_obj;
            #line 4737 "Python/generated_cases.c.h"
            stack_pointer[-1] = func;
            DISPATCH();
        }

        TARGET(SET_FUNCTION_ATTRIBUTE) {
            PyObject *func = stack_pointer[-1];
            PyObject *attr = stack_pointer[-2];
            #line 3441 "Python/bytecodes.c"
            assert(PyFunction_Check(func));
            PyFunctionObject *func_obj = (PyFunctionObject *)func;
            switch(oparg) {
                case MAKE_FUNCTION_CLOSURE:
                    assert(func_obj->func_closure == NULL);
                    func_obj->func_closure = attr;
                    break;
                case MAKE_FUNCTION_ANNOTATIONS:
                    assert(func_obj->func_annotations == NULL);
                    func_obj->func_annotations = attr;
                    break;
                case MAKE_FUNCTION_KWDEFAULTS:
                    assert(PyDict_CheckExact(attr));
                    assert(func_obj->func_kwdefaults == NULL);
                    func_obj->func_kwdefaults = attr;
                    break;
                case MAKE_FUNCTION_DEFAULTS:
                    assert(PyTuple_CheckExact(attr));
                    assert(func_obj->func_defaults == NULL);
                    func_obj->func_defaults = attr;
                    break;
                default:
                    Py_UNREACHABLE();
            }
            #line 4770 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = func;
            DISPATCH();
        }

        TARGET(RETURN_GENERATOR) {
            #line 3468 "Python/bytecodes.c"
            assert(PyFunction_Check(frame->f_funcobj));
            PyFunctionObject *func = (PyFunctionObject *)frame->f_funcobj;
            PyGenObject *gen = (PyGenObject *)_Py_MakeCoro(func);
            if (gen == NULL) {
                goto error;
            }
            assert(EMPTY());
            _PyFrame_SetStackPointer(frame, stack_pointer);
            _PyInterpreterFrame *gen_frame = (_PyInterpreterFrame *)gen->gi_iframe;
            _PyFrame_Copy(frame, gen_frame);
            assert(frame->frame_obj == NULL);
            gen->gi_frame_state = FRAME_CREATED;
            gen_frame->owner = FRAME_OWNED_BY_GENERATOR;
            _Py_LeaveRecursiveCallPy(tstate);
            assert(frame != &entry_frame);
            _PyInterpreterFrame *prev = frame->previous;
            _PyThreadState_PopFrame(tstate, frame);
            frame = cframe.current_frame = prev;
            _PyFrame_StackPush(frame, (PyObject *)gen);
            goto resume_frame;
            #line 4798 "Python/generated_cases.c.h"
        }

        TARGET(BUILD_SLICE) {
            PyObject *step = (oparg == 3) ? stack_pointer[-(((oparg == 3) ? 1 : 0))] : NULL;
            PyObject *stop = stack_pointer[-(1 + ((oparg == 3) ? 1 : 0))];
            PyObject *start = stack_pointer[-(2 + ((oparg == 3) ? 1 : 0))];
            PyObject *slice;
            #line 3491 "Python/bytecodes.c"
            slice = PySlice_New(start, stop, step);
            #line 4808 "Python/generated_cases.c.h"
            Py_DECREF(start);
            Py_DECREF(stop);
            Py_XDECREF(step);
            #line 3493 "Python/bytecodes.c"
            if (slice == NULL) { STACK_SHRINK(((oparg == 3) ? 1 : 0)); goto pop_2_error; }
            #line 4814 "Python/generated_cases.c.h"
            STACK_SHRINK(((oparg == 3) ? 1 : 0));
            STACK_SHRINK(1);
            stack_pointer[-1] = slice;
            DISPATCH();
        }

        TARGET(CONVERT_VALUE) {
            PyObject *value = stack_pointer[-1];
            PyObject *result;
            #line 3497 "Python/bytecodes.c"
            convertion_func_ptr  conv_fn;
            assert(oparg >= FVC_STR && oparg <= FVC_ASCII);
            conv_fn = CONVERSION_FUNCTIONS[oparg];
            result = conv_fn(value);
            Py_DECREF(value);
            if (result == NULL) goto pop_1_error;
            #line 4831 "Python/generated_cases.c.h"
            stack_pointer[-1] = result;
            DISPATCH();
        }

        TARGET(FORMAT_SIMPLE) {
            PyObject *value = stack_pointer[-1];
            PyObject *res;
            #line 3506 "Python/bytecodes.c"
            /* If value is a unicode object, then we know the result
             * of format(value) is value itself. */
            if (!PyUnicode_CheckExact(value)) {
                res = PyObject_Format(value, NULL);
                Py_DECREF(value);
                if (res == NULL) goto pop_1_error;
            }
            else {
                res = value;
            }
            #line 4850 "Python/generated_cases.c.h"
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(FORMAT_WITH_SPEC) {
            PyObject *fmt_spec = stack_pointer[-1];
            PyObject *value = stack_pointer[-2];
            PyObject *res;
            #line 3519 "Python/bytecodes.c"
            res = PyObject_Format(value, fmt_spec);
            Py_DECREF(value);
            Py_DECREF(fmt_spec);
            if (res == NULL) goto pop_2_error;
            #line 4864 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            DISPATCH();
        }

        TARGET(COPY) {
            PyObject *bottom = stack_pointer[-(1 + (oparg-1))];
            PyObject *top;
            #line 3526 "Python/bytecodes.c"
            assert(oparg > 0);
            top = Py_NewRef(bottom);
            #line 4876 "Python/generated_cases.c.h"
            STACK_GROW(1);
            stack_pointer[-1] = top;
            DISPATCH();
        }

        TARGET(BINARY_OP) {
            PREDICTED(BINARY_OP);
            static_assert(INLINE_CACHE_ENTRIES_BINARY_OP == 1, "incorrect cache size");
            PyObject *rhs = stack_pointer[-1];
            PyObject *lhs = stack_pointer[-2];
            PyObject *res;
            #line 3531 "Python/bytecodes.c"
            #if ENABLE_SPECIALIZATION
            _PyBinaryOpCache *cache = (_PyBinaryOpCache *)next_instr;
            if (ADAPTIVE_COUNTER_IS_ZERO(cache->counter)) {
                next_instr--;
                _Py_Specialize_BinaryOp(lhs, rhs, next_instr, oparg, &GETLOCAL(0));
                DISPATCH_SAME_OPARG();
            }
            STAT_INC(BINARY_OP, deferred);
            DECREMENT_ADAPTIVE_COUNTER(cache->counter);
            #endif  /* ENABLE_SPECIALIZATION */
            assert(0 <= oparg);
            assert((unsigned)oparg < Py_ARRAY_LENGTH(binary_ops));
            assert(binary_ops[oparg]);
            res = binary_ops[oparg](lhs, rhs);
            #line 4903 "Python/generated_cases.c.h"
            Py_DECREF(lhs);
            Py_DECREF(rhs);
            #line 3546 "Python/bytecodes.c"
            if (res == NULL) goto pop_2_error;
            #line 4908 "Python/generated_cases.c.h"
            STACK_SHRINK(1);
            stack_pointer[-1] = res;
            next_instr += 1;
            DISPATCH();
        }

        TARGET(SWAP) {
            PyObject *top = stack_pointer[-1];
            PyObject *bottom = stack_pointer[-(2 + (oparg-2))];
            #line 3551 "Python/bytecodes.c"
            assert(oparg >= 2);
            #line 4920 "Python/generated_cases.c.h"
            stack_pointer[-1] = bottom;
            stack_pointer[-(2 + (oparg-2))] = top;
            DISPATCH();
        }

        TARGET(INSTRUMENTED_INSTRUCTION) {
            #line 3555 "Python/bytecodes.c"
            int next_opcode = _Py_call_instrumentation_instruction(
                tstate, frame, next_instr-1);
            if (next_opcode < 0) goto error;
            next_instr--;
            if (_PyOpcode_Caches[next_opcode]) {
                _PyBinaryOpCache *cache = (_PyBinaryOpCache *)(next_instr+1);
                INCREMENT_ADAPTIVE_COUNTER(cache->counter);
            }
            assert(next_opcode > 0 && next_opcode < 256);
            opcode = next_opcode;
            DISPATCH_GOTO();
            #line 4939 "Python/generated_cases.c.h"
        }

        TARGET(INSTRUMENTED_JUMP_FORWARD) {
            #line 3569 "Python/bytecodes.c"
            INSTRUMENTED_JUMP(next_instr-1, next_instr+oparg, PY_MONITORING_EVENT_JUMP);
            #line 4945 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_JUMP_BACKWARD) {
            #line 3573 "Python/bytecodes.c"
            INSTRUMENTED_JUMP(next_instr-1, next_instr+1-oparg, PY_MONITORING_EVENT_JUMP);
            #line 4952 "Python/generated_cases.c.h"
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }

        TARGET(INSTRUMENTED_POP_JUMP_IF_TRUE) {
            #line 3578 "Python/bytecodes.c"
            PyObject *cond = POP();
            assert(PyBool_Check(cond));
            _Py_CODEUNIT *here = next_instr - 1;
            int offset = Py_IsTrue(cond) * oparg;
            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);
            #line 4964 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_POP_JUMP_IF_FALSE) {
            #line 3586 "Python/bytecodes.c"
            PyObject *cond = POP();
            assert(PyBool_Check(cond));
            _Py_CODEUNIT *here = next_instr - 1;
            int offset = Py_IsFalse(cond) * oparg;
            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);
            #line 4975 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_POP_JUMP_IF_NONE) {
            #line 3594 "Python/bytecodes.c"
            PyObject *value = POP();
            _Py_CODEUNIT *here = next_instr-1;
            int offset;
            if (Py_IsNone(value)) {
                offset = oparg;
            }
            else {
                Py_DECREF(value);
                offset = 0;
            }
            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);
            #line 4992 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(INSTRUMENTED_POP_JUMP_IF_NOT_NONE) {
            #line 3608 "Python/bytecodes.c"
            PyObject *value = POP();
            _Py_CODEUNIT *here = next_instr-1;
            int offset;
            if (Py_IsNone(value)) {
                offset = 0;
            }
            else {
                Py_DECREF(value);
                offset = oparg;
            }
            INSTRUMENTED_JUMP(here, next_instr + offset, PY_MONITORING_EVENT_BRANCH);
            #line 5009 "Python/generated_cases.c.h"
            DISPATCH();
        }

        TARGET(EXTENDED_ARG) {
            #line 3622 "Python/bytecodes.c"
            assert(oparg);
            opcode = next_instr->op.code;
            oparg = oparg << 8 | next_instr->op.arg;
            PRE_DISPATCH_GOTO();
            DISPATCH_GOTO();
            #line 5020 "Python/generated_cases.c.h"
        }

        TARGET(CACHE) {
            #line 3630 "Python/bytecodes.c"
            assert(0 && "Executing a cache.");
            Py_UNREACHABLE();
            #line 5027 "Python/generated_cases.c.h"
        }

        TARGET(RESERVED) {
            #line 3635 "Python/bytecodes.c"
            assert(0 && "Executing RESERVED instruction.");
            Py_UNREACHABLE();
            #line 5034 "Python/generated_cases.c.h"
        }
